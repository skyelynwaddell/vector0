/*
This file was automatically generated by FTE Quake v1.06
This file can be regenerated by issuing the following command:
pr_dumpplatform -O ssdefs -Tqw -Ffte
Available options:
-Ffte       - target only FTE (optimations and additional extensions)
-Tnq        - dump specifically NQ fields
-Tqw        - dump specifically QW fields
-Tcs        - dump specifically CSQC fields
-Tmenu      - dump specifically menuqc fields
-Fdefines   - generate #defines instead of constants
-Faccessors - use accessors instead of basic types via defines
-O          - write to a different qc file
*/
#pragma noref 1
//#pragma flag enable logicops
#pragma warning error Q101 /*too many parms*/
#pragma warning error Q105 /*too few parms*/
#pragma warning error Q106 /*assignment to constant/lvalue*/
#pragma warning error Q208 /*system crc unknown*/
#pragma warning disable F211 /*system crc outdated (eg: dp's csqc)*/
#pragma warning enable F301 /*non-utf-8 strings*/
#pragma warning enable F302 /*uninitialised locals*/
#pragma target FTE
#ifndef QUAKEWORLD
#define QUAKEWORLD
#endif
#ifndef QWSSQC
#define QWSSQC
#endif
#ifndef SSQC
#define SSQC
#endif
#define FTE_PEXT_SETVIEW /* NQ's svc_setview works correctly even in quakeworld */
#define DP_ENT_SCALE
#define FTE_PEXT_LIGHTSTYLECOL
#define DP_ENT_ALPHA
#define FTE_PEXT_VIEW2
#define FTE_PEXT_ACURATETIMINGS
#define FTE_PEXT_SOUNDDBL
#define FTE_PEXT_FATNESS
#define DP_HALFLIFE_MAP
#define FTE_PEXT_TE_BULLET
#define FTE_PEXT_HULLSIZE
#define FTE_PEXT_MODELDBL
#define FTE_PEXT_ENTITYDBL
#define FTE_PEXT_ENTITYDBL2
#define FTE_PEXT_FLOATCOORDS
#define FTE_PEXT_VWEAP
#define FTE_PEXT_Q2BSP
#define FTE_PEXT_Q3BSP
#define DP_ENT_COLORMOD
#define FTE_HEXEN2
#define FTE_PEXT_SPAWNSTATIC
#define FTE_PEXT_CUSTOMTENTS
#define FTE_PEXT_256PACKETENTITIES
#define TEI_SHOWLMP2
#define DP_GFX_QUAKE3MODELTAGS
#define FTE_PK3DOWNLOADS
#define PEXT_CHUNKEDDOWNLOADS
#define EXT_CSQC_SHARED
#define PEXT_DPFLAGS
#define EXT_CSQC
#define BX_COLOREDTEXT
#define DP_CON_SET /* The 'set' console command exists, and can be used to create/set cvars. */
#define DP_CON_SETA /* The 'seta' console command exists, like the 'set' command, but also marks the cvar for archiving, allowing it to be written into the user's config. Use this command in your default.cfg file. */
#define DP_EF_ADDITIVE
#define DP_EF_BLUE
#define DP_EF_FULLBRIGHT
#define DP_EF_NODEPTHTEST
#define DP_EF_NODRAW
#define DP_EF_NOGUNBOB
#define DP_EF_NOSHADOW
#define DP_EF_RED
#define DP_ENT_CUSTOMCOLORMAP
#define DP_ENT_EXTERIORMODELTOCLIENT
#define DP_ENT_TRAILEFFECTNUM /* self.traileffectnum=particleeffectnum("myeffectname"); can be used to attach a particle trail to the given server entity. This is equivelent to calling trailparticles each frame. */
#define DP_ENT_VIEWMODEL
#define DP_GECKO_SUPPORT
#define DP_GFX_FONTS
#define DP_GFX_SKINFILES
#define DP_GFX_SKYBOX
#define DP_HALFLIFE_MAP_CVAR
#define DP_INPUTBUTTONS
#define DP_LIGHTSTYLE_STATICVALUE
#define DP_LITSUPPORT
#define DP_MD3_TAGSINFO
#define DP_MONSTERWALK /* MOVETYPE_WALK is valid on non-player entities. Note that only players receive acceleration etc in line with none/bounce/fly/noclip movetypes on the player, thus you will have to provide your own accelerations (incluing gravity) yourself. */
#define DP_MOVETYPEBOUNCEMISSILE
#define DP_MOVETYPEFOLLOW
#define DP_QC_ASINACOSATANATAN2TAN
#define DP_QC_CHANGEPITCH
#define DP_QC_COPYENTITY
#define DP_QC_CRC16
#define DP_QC_CVAR_DEFSTRING
#define DP_QC_CVAR_STRING
#define DP_QC_CVAR_TYPE
#define DP_QC_EDICT_NUM
#define DP_QC_ENTITYDATA
#define DP_QC_ETOS
#define DP_QC_FINDCHAIN
#define DP_QC_FINDCHAINFLOAT
#define DP_QC_FINDFLAGS
#define DP_QC_FINDCHAINFLAGS
#define DP_QC_FINDFLOAT
#define DP_QC_FS_SEARCH
#define DP_QC_GETSURFACE
#define DP_QC_GETSURFACEPOINTATTRIBUTE
#define DP_QC_MINMAXBOUND
#define DP_QC_MULTIPLETEMPSTRINGS /* Superseded by DP_QC_UNLIMITEDTEMPSTRINGS. Functions that return a temporary string will not overwrite/destroy previous temporary strings until at least 16 strings are returned (or control returns to the engine). */
#define DP_QC_RANDOMVEC
#define DP_QC_RENDER_SCENE /* clearscene+addentity+setviewprop+renderscene+setmodel are available to menuqc. WARNING: DP advertises this extension without actually supporting it, FTE does actually support it. */
#define DP_QC_SINCOSSQRTPOW
#define DP_QC_SPRINTF /* Provides the sprintf builtin, which allows for rich formatting along the lines of C's function with the same name. Not to be confused with QC's sprint builtin. */
#define DP_QC_STRFTIME
#define DP_QC_STRING_CASE_FUNCTIONS
#define DP_QC_STRINGBUFFERS
#define DP_QC_STRINGCOLORFUNCTIONS
#define DP_QC_STRREPLACE
#define DP_QC_TOKENIZEBYSEPARATOR
#define DP_QC_TRACEBOX
#define DP_QC_TRACETOSS
#define DP_QC_TRACE_MOVETYPE_HITMODEL
#define DP_QC_TRACE_MOVETYPE_WORLDONLY
#define DP_QC_TRACE_MOVETYPES
#define DP_QC_UNLIMITEDTEMPSTRINGS /* Supersedes DP_QC_MULTIPLETEMPSTRINGS, superseded by FTE_QC_PERSISTENTTEMPSTRINGS. Specifies that all temp strings will be valid at least until the QCVM returns. */
#define DP_QC_URI_ESCAPE
#define DP_QC_URI_GET
#define DP_QC_URI_POST
#define DP_QC_VECTOANGLES_WITH_ROLL
#define DP_QC_VECTORVECTORS
#define DP_QC_WHICHPACK
#define DP_QUAKE2_MODEL
#define DP_QUAKE2_SPRITE
#define DP_QUAKE3_MODEL
#define DP_REGISTERCVAR
#define DP_SND_SOUND7_WIP2
#define DP_SND_STEREOWAV
#define DP_SND_OGGVORBIS
#define DP_SOLIDCORPSE
#define DP_SPRITE32
#define DP_SV_BOTCLIENT
#define DP_SV_CLIENTCOLORS /* Provided only for compatibility with DP. */
#define DP_SV_CLIENTNAME /* Provided only for compatibility with DP. */
#define DP_SV_DRAWONLYTOCLIENT
#define DP_SV_DROPCLIENT /* Equivelent to quakeworld's stuffcmd(self,"disconnect\n"); hack */
#define DP_SV_EFFECT
#define DP_SV_EXTERIORMODELFORCLIENT
#define DP_SV_NODRAWTOCLIENT
#define DP_SV_PLAYERPHYSICS /* Allows reworking parts of NQ player physics. USE AT OWN RISK - this necessitates NQ physics and is thus guarenteed to break prediction. */
#define DP_SV_POINTSOUND
#define DP_SV_PRECACHEANYTIME /* Specifies that the various precache builtins can be called at any time. WARNING: precaches are sent reliably while sound events, modelindexes, and particle events are not. This can mean sounds and particles might not work the first time around, or models may take a while to appear (after the reliables are received and the model is loaded from disk). Always attempt to precache a little in advance in order to reduce these issues (preferably at the start of the map...) */
#define DP_SV_PRINT /* Says that the print builtin can be used from nqssqc (as well as just csqc), bypassing the developer cvar issues. */
#define DP_SV_SETCOLOR
#define DP_SV_SPAWNFUNC_PREFIX
#define DP_SV_WRITEPICTURE
#define DP_SV_WRITEUNTERMINATEDSTRING
#define DP_TE_BLOOD
#define DP_TE_CUSTOMFLASH
#define DP_TE_EXPLOSIONRGB
#define DP_TE_PARTICLECUBE
#define DP_TE_PARTICLERAIN
#define DP_TE_PARTICLESNOW
#define DP_TE_SMALLFLASH
#define DP_TE_SPARK
#define DP_TE_STANDARDEFFECTBUILTINS
#define DP_VIEWZOOM
#define EXT_BITSHIFT
#define EXT_DIMENSION_VISIBILITY
#define EXT_DIMENSION_PHYSICS
#define EXT_DIMENSION_GHOST
#define FRIK_FILE
#define FTE_CALLTIMEOFDAY /* Replication of mvdsv functionality (call calltimeofday to cause 'timeofday' to be called, with arguments that can be saved off to a global). Generally strftime is simpler to use. */
#define FTE_CSQC_ALTCONSOLES /* The engine tracks multiple consoles. These may or may not be directly visible to the user. */
#define FTE_CSQC_BASEFRAME /* Specifies that .basebone, .baseframe2, .baselerpfrac, baseframe1time, etc exist in csqc. These fields affect all bones in the entity's model with a lower index than the .basebone field, allowing you to give separate control to the legs of a skeletal model, without affecting the torso animations. */
#define FTE_CSQC_HALFLIFE_MODELS
#define FTE_CSQC_SERVERBROWSER /* Provides builtins to query the engine's serverbrowser servers list from ssqc. Note that these builtins are always available in menuqc. */
#define FTE_CSQC_SKELETONOBJECTS /* Provides container objects for skeletal bone data, which can be modified on a per bone basis if needed. This allows you to dynamically generate animations (or just blend them with greater customisation) instead of being limited to a single animation or two. */
#define FTE_CSQC_RAWIMAGES /* Provides raw rgba image access to csqc. With this, the csprogs can read textures into qc-accessible memory, modify it, and then upload it to the renderer. */
#define FTE_CSQC_RENDERTARGETS /* VF_RT_DESTCOLOUR exists and can be used to redirect any rendering to a texture instead of the screen. */
#define FTE_CSQC_REVERB /* Specifies that the mod can create custom reverb effects. Whether they will actually be used or not depends upon the sound driver. */
#define FTE_CSQC_WINDOWCAPTION /* Provides csqc with the ability to change the window caption as displayed when running windowed or in the task bar when switched out. */
#define FTE_ENT_SKIN_CONTENTS /* self.skin = CONTENTS_WATER; makes a brush entity into water. use -16 for a ladder. */
#define FTE_ENT_UNIQUESPAWNID
#define FTE_EXTENDEDTEXTCODES
#define FTE_FORCESHADER /* Allows csqc to override shaders on models with an explicitly named replacement. Also allows you to define shaders with a fallback if it does not exist on disk. */
#define FTE_FORCEINFOKEY /* Provides an easy way to change a user's userinfo from the server. */
#define FTE_GFX_QUAKE3SHADERS /* specifies that the engine has full support for vanilla quake3 shaders */
#define FTE_GFX_REMAPSHADER /* With the raw power of stuffcmds, the r_remapshader console command is exposed! This mystical command can be used to remap any shader to another. Remapped shaders that specify $diffuse etc in some form will inherit the textures implied by the surface. */
#define FTE_GFX_MODELEVENTS /* Provides a query for per-animation events in model files, including from progs/foo.mdl.events files. */
#define FTE_ISBACKBUFFERED /* Allows you to check if a client has too many reliable messages pending. */
#define FTE_MEMALLOC /* Allows dynamically allocating memory. Use pointers to access this memory. Memory will not be saved into saved games. */
#define FTE_MEDIA_AVI /* playfilm command supports avi files. */
#define FTE_MEDIA_CIN /* playfilm command supports q2 cin files. */
#define FTE_MEDIA_ROQ /* playfilm command supports q3 roq files. */
#define FTE_MULTIPROGS /* Multiple progs.dat files can be loaded inside the same qcvm. Insert new ones with addprogs inside the 'init' function, and use externvalue+externset to rewrite globals (and hook functions) to link them together. Note that the result is generally not very clean unless you carefully design for it beforehand. */
#define FTE_MULTITHREADED /* Faux multithreading, allowing multiple contexts to run in sequence. */
#define FTE_MVD_PLAYERSTATS /* In csqc, getplayerstat can be used to query any player's stats when playing back MVDs. isdemo will return 2 in this case. */
#define FTE_QC_NPCCHAT
#define FTE_PART_SCRIPT /* Specifies that the r_particledesc cvar can be used to select a list of particle effects to load from particles/*.cfg, the format of which is documented elsewhere. */
#define FTE_PART_NAMESPACES /* Specifies that the engine can use foo.bar to load effect foo from particle description bar. When used via ssqc, this should cause the client to download whatever effects as needed. */
#define FTE_PART_NAMESPACE_EFFECTINFO /* Specifies that effectinfo.bar can load effects from effectinfo.txt for DP compatibility. */
#define FTE_QC_BASEFRAME /* Specifies that .basebone and .baseframe exist in ssqc. These fields affect all bones in the entity's model with a lower index than the .basebone field, allowing you to give separate control to the legs of a skeletal model, without affecting the torso animations, from ssqc. */
#define FTE_QC_FILE_BINARY /* Extends FRIK_FILE with binary read+write, as well as allowing seeking. Requires pointers. */
#define FTE_QC_CHANGELEVEL_HUB /* Adds an extra argument to changelevel which is carried over to the next map in the 'spawnspot' global. Maps will be saved+reloaded until the extra argument is omitted again, purging all saved maps. Saved games will contain a copy of each preserved map. parm1-parm64 globals can be used, giving more space to transfer more player data. */
#define FTE_QC_CHECKCOMMAND /* Provides a way to test if a console command exists, and whether its a command/alias/cvar. Does not say anything about the expected meanings of any arguments or values. */
#define FTE_QC_CHECKPVS
#define FTE_QC_CROSSPRODUCT
#define FTE_QC_CUSTOMSKINS /* The engine supports the use of q3 skins, as well as the use of such skin 'files' to specify rich top+bottom colours, qw skins, geomsets, or texture composition even on non-players.. */
#define FTE_QC_FS_SEARCH_SIZEMTIME
#define FTE_QC_HARDWARECURSORS /* setcursormode exists in both csqc+menuqc, and accepts additional arguments to specify a cursor image to use when this module has focus. If the image exceeds hardware limits (or hardware cursors are unsupported), it will be emulated using regular draws - this at least still avoids conflicting cursors as only one will ever be used, even if console+menu+csqc are all overlayed. */
#define FTE_QC_HASHTABLES /* Provides efficient string-based lookups. */
#define FTE_QC_INFOKEY /* QuakeWorld's infokey builtin works, and reports at least name+topcolor+bottomcolor+ping(in ms)+ip(unmasked, but not always ipv4)+team(aka bottomcolor in nq). Does not require actual localinfo/serverinfo/userinfo, but they're _highly_ recommended to any engines with csqc */
#define FTE_QC_INTCONV /* Provides string<>int conversions, including hex representations. */
#define FTE_QC_MATCHCLIENTNAME
#define FTE_QC_MULTICAST /* QuakeWorld's multicast builtin works along with MSG_MULTICAST, but also with unicast support. */
#define FTE_QC_PAUSED
#define FTE_QC_PERSISTENTTEMPSTRINGS /* Supersedes DP_QC_MULTIPLETEMPSTRINGS. Temp strings are garbage collected automatically, and do not expire while they're still in use. This makes strzone redundant. */
#define FTE_QC_RAGDOLL_WIP
#define FTE_QC_SENDPACKET /* Allows the use of out-of-band udp packets to/from other hosts. Includes the SV_ParseConnectionlessPacket event. */
#define FTE_QC_STUFFCMDFLAGS /* Variation on regular stuffcmd that gives control over how spectators/mvds should be treated. */
#define FTE_QC_TRACETRIGGER
#define FTE_QUAKE2_CLIENT /* This engine is able to act as a quake2 client */
#define FTE_QUAKE2_SERVER /* This engine is able to act as a quake2 server */
#define FTE_QUAKE3_CLIENT /* This engine is able to act as a quake3 client */
#define FTE_QUAKE3_SERVER /* This engine is able to act as a quake3 server */
#define FTE_SOLID_LADDER /* Allows a simple trigger to remove effects of gravity (solid 20). obsolete. will prolly be removed at some point as it is not networked properly. Use FTE_ENT_SKIN_CONTENTS */
#define FTE_SPLITSCREEN /* Client supports splitscreen, controlled via cl_splitclients. Servers require allow_splitscreen 1 if splitscreen is to be used over the internet. Mods that use csqc will need to be aware for this to work properly. per-client networking may be problematic. */
#define FTE_SQL /* Provides sql* builtins which can be used for sql database access */
#define FTE_SQL_SQLITE /* SQL functionality is able to utilise sqlite databases */
#define FTE_STRINGS /* Extra builtins (and additional behaviour) to make string manipulation easier */
#define FTE_SV_POINTPARTICLES /* Specifies that particleeffectnum, pointparticles, and trailparticles exist in ssqc as well as csqc. particleeffectnum acts as a precache, allowing ssqc values to be networked up with csqc for use. Use in combination with FTE_PART_SCRIPT+FTE_PART_NAMESPACES to use custom effects. This extension is functionally identical to the DP version, but avoids any misplaced assumptions about the format of the client's particle descriptions. */
#define FTE_SV_REENTER
#define FTE_TE_STANDARDEFFECTBUILTINS /* Provides builtins to replace writebytes, with a QW compatible twist. */
#define FTE_TERRAIN_MAP /* This engine supports .hmp files, as well as terrain embedded within bsp files. */
#define FTE_RAW_MAP /* This engine supports directly loading .map files, as well as realtime editing of the various brushes. */
#define KRIMZON_SV_PARSECLIENTCOMMAND /* SSQC's SV_ParseClientCommand function is able to handle client 'cmd' commands. The tokenizing parts also work in csqc. */
#define NEH_CMD_PLAY2
#define NEH_RESTOREGAME
#define QSG_CVARSTRING
#define QW_ENGINE
#define QWE_MVD_RECORD /* You can use the easyrecord command to record MVD demos serverside. */
#define TEI_MD3_MODEL
#define TENEBRAE_GFX_DLIGHTS /* Allows ssqc to attach rtlights to entities with various special properties. */
#define ZQ_MOVETYPE_FLY /* MOVETYPE_FLY works on players. */
#define ZQ_MOVETYPE_NOCLIP /* MOVETYPE_NOCLIP works on players. */
#define ZQ_MOVETYPE_NONE /* MOVETYPE_NONE works on players. */
#define ZQ_VWEP
#define ZQ_QC_STRINGS /* The strings-only subset of FRIK_FILE is supported. */

#ifdef _ACCESSORS
accessor strbuf : float;
accessor searchhandle : float;
accessor hashtable : float;
accessor infostring : string;
accessor filestream : float;
accessor filestream : float;
#else
#define strbuf float
#define searchhandle float
#define hashtable float
#define infostring string
#define filestream float
#endif

entity self;	/* The magic me */
entity other;	/* Valid in touch functions, this is the entity that we touched. */
entity world;	/* The null entity. Hurrah. Readonly after map spawn time. */
float time;	/* The current game time. Stops when paused. */
float frametime;	/* The time since the last physics/render/input frame. */
entity newmis;	/* A named entity that should be run soon, to reduce the effects of latency. */
float force_retouch;	/* If positive, causes all entities to check for triggers. */
string mapname;	/* The short name of the map. */
float serverflags;
float total_secrets;
float total_monsters;
float found_secrets;
float killed_monsters;
float parm1, parm2, parm3, parm4, parm5, parm6, parm7, parm8, parm9, parm10, parm11, parm12, parm13, parm14, parm15, parm16;
vector v_forward, v_up, v_right;
float trace_allsolid, trace_startsolid, trace_fraction;
vector trace_endpos, trace_plane_normal;
float trace_plane_dist;
entity trace_ent;
float trace_inopen;
float trace_inwater;
entity msg_entity;
void main();
void StartFrame();
void PlayerPreThink();
void PlayerPostThink();
void ClientKill();
void ClientConnect();
void PutClientInServer();
void ClientDisconnect();
void SetNewParms();
void SetChangeParms();
void end_sys_globals;
.float modelindex;	/* This is the model precache index for the model that was set on the entity, instead of having to look up the model according to the .model field. Use setmodel to change it. */
.vector absmin;	/* Set by the engine when the entity is relinked (by setorigin, setsize, or setmodel). This is in world coordinates. */
.vector absmax;	/* Set by the engine when the entity is relinked (by setorigin, setsize, or setmodel). This is in world coordinates. */
.float ltime;	/* On MOVETYPE_PUSH entities, this is used as an alternative to the 'time' global, and .nextthink is synced to this instead of time. This allows time to effectively freeze if the entity is blocked, ensuring the think happens when the entity reaches the target point instead of randomly. */
.float lastruntime;	/* This field used to be used to avoid running an entity multiple times in a single frame due to quakeworld's out-of-order thinks. It is no longer used by FTE due to precision issues, but may still be updated for compatibility reasons. */
.float movetype;	/* Describes how the entity moves. One of the MOVETYPE_ constants. */
.float solid;	/* Describes whether the entity is solid or not, and any special properties infered by that. Must be one of the SOLID_ constants */
.vector origin;	/* The current location of the entity in world space. Inline bsp entities (ie: ones placed by a mapper) will typically have a value of '0 0 0' in their neutral pose, as the geometry is offset from that. It is the reference point of the entity rather than the center of its geometry, for non-bsp models, this is often not a significant distinction. */
.vector oldorigin;	/* This is often used on players to reset the player back to where they were last frame if they somehow got stuck inside something due to fpu precision. Never change a player's oldorigin field to inside a solid, because that might cause them to become pemanently stuck. */
.vector velocity;	/* The direction and speed that the entity is moving in world space. */
.vector angles;	/* The eular angles the entity is facing in, in pitch, yaw, roll order. Due to a legacy bug, mdl/iqm/etc formats use +x=UP, bsp/spr/etc formats use +x=DOWN. */
.vector avelocity;	/* The amount the entity's angles change by per second. Note that this is direct eular angles, and thus the angular change is non-linear and often just looks buggy if you're changing more than one angle at a time. */
.string classname;	/* Identifies the class/type of the entity. Useful for debugging, also used for loading, but its value is not otherwise significant to the engine, this leaves the mod free to set it to whatever it wants and randomly test strings for values in whatever inefficient way it chooses fit. */
.string model;	/* The model name that was set via setmodel, in theory. Often, this is cleared to null to prevent the engine from being seen by clients while not changing modelindex. This behaviour allows inline models to remain solid yet be invisible. */
.float frame;	/* The current frame the entity is meant to be displayed in. In CSQC, note the lerpfrac and frame2 fields as well. if it specifies a framegroup, the framegroup will autoanimate in ssqc, but not in csqc. */
.float skin;	/* The skin index to use. on a bsp entity, setting this to 1 will switch to the 'activated' texture instead. A negative value will be understood as a replacement contents value, so setting it to CONTENTS_WATER will make a movable pool of water. */
.float effects;	/* Lots of random flags that change random effects. See EF_* constants. */
.vector mins;	/* The minimum extent of the model (ie: the bottom-left coordinate relative to the entity's origin). Change via setsize. May also be changed by setmodel. */
.vector maxs;	/* like mins, but in the other direction. */
.vector size;	/* maxs-mins. Updated when the entity is relinked (by setorigin, setsize, setmodel) */
.void() touch;
.void() use;
.void() think;
.void() blocked;
.float nextthink;	/* The time at which the entity is next scheduled to fire its think event. For MOVETYPE_PUSH entities, this is relative to that entity's ltime field, for all other entities it is relative to the time gloal. */
.entity groundentity;
.float health;
.float frags;
.float weapon;
.string weaponmodel;
.float weaponframe;
.float currentammo;
.float ammo_shells;
.float ammo_nails;
.float ammo_rockets;
.float ammo_cells;
.float items;
.float takedamage;
.entity chain;
.float deadflag;
.vector view_ofs;
.float button0;
.float button1;
.float button2;
.float impulse;
.float fixangle;	/* Forces the clientside view angles to change to the value of .angles (has some lag). If set to 1/TRUE, the server will guess whether to send a delta or an explicit angle. If 2, will always send a delta (due to lag between transmission and acknowledgement, this cannot be spammed reliably). If 3, will always send an explicit angle. */
.vector v_angle;	/* The angles a player is viewing. +x is DOWN (pitch, yaw, roll) */
.string netname;
.entity enemy;
.float flags;
.float colormap;
.float team;
.float max_health;
.float teleport_time;	/* While active, prevents the player from using the +back command, also blocks waterjumping. */
.float armortype;
.float armorvalue;
.float waterlevel;
.float watertype;
.float ideal_yaw;
.float yaw_speed;
.entity aiment;
.entity goalentity;
.float spawnflags;
.string target;
.string targetname;
.float dmg_take;
.float dmg_save;
.entity dmg_inflictor;
.entity owner;
.vector movedir;
.string message;
.float sounds;
.string noise;
.string noise1;
.string noise2;
.string noise3;
void end_sys_fields;
float input_timelength;
vector input_angles;	/* +x=DOWN */
vector input_movevalues;
float input_buttons;
float input_impulse;
int trace_endcontents;
int trace_surfaceflags;
int trace_brush_id;
int trace_brush_faceid;
int trace_surface_id;	/* 1-based. 0 if not known. */
int trace_bone_id;	/* 1-based. 0 if not known. typically needs MOVE_HITMODEL. */
int trace_triangle_id;	/* 1-based. 0 if not known. */
vector global_gravitydir = '0 0 -1';	/* The direction gravity should act in if not otherwise specified per entity. */
int serverid;	/* The unique id of this server within the server cluster. */
.vector punchangle;
.float gravity;
.float hull;	/* Overrides the hull used by the entity for walkmove/movetogoal and not traceline/tracebox. */
.entity movechain;	/* This is a linked list of entities which will be moved whenever this entity moves, logically they are attached to this entity. */
.void() chainmoved;	/* Called when the entity is moved as a result of being part of another entity's .movechain */
.void(float old, float new) contentstransition;	/* This function is called when the entity moves between water and air. If specified, default splash sounds will be disabled allowing you to provide your own. */
.float dimension_solid;	/* This is the bitmask of dimensions which the entity is solid within. */
.float dimension_hit;	/* This is the bitmask of dimensions which the entity will be blocked by. If other.dimension_solid & self.dimension_hit, our traces will impact and not proceed. If its false, the traces will NOT impact, allowing self to pass straight through. */
.int hitcontentsmaski;	/* Traces performed for this entity will impact against surfaces that match this contents mask. */
.float dphitcontentsmask;	/* Some crappy field that inefficiently requires translating to the native contents flags. Ditch the 'dp', do it properly. */
.float scale;	/* Multiplier that resizes the entity. 1 is normal sized, 2 is double sized. scale 0 is remapped to 1. In SSQC, this is limited to 1/16th precision, with a maximum just shy of 16. */
.float fatness;	/* How many QuakeUnits to push the entity's verticies along their normals by. */
.float alpha;	/* The transparency of the entity. 1 means opaque, 0.0001 means virtually invisible. 0 is remapped to 1, for compatibility. */
.float modelflags;	/* Used to override the flags set in the entity's model. Should be set according to the MF_ constants. Use effects|=EF_NOMODELFLAGS to ignore the model's flags completely. The traileffectnum field is more versatile. */
.float frame1time;	/* This controls the time into the framegroup/animation named by .frame, you should increment this value according to frametime or to distance moved, depending on the sort of animation you're attempting. You may wish to avoid incrementing this while lerpfrac is still changing, to avoid wasting parts of the animation. */
.float basebone;	/* The base* frame animations are equivelent to their non-base versions, except that they only affect bone numbers below the 'basebone' value. This means that the base* animation can affect the legs of a skeletal model independantly of the normal animation fields affecting the torso area. For more complex animation than this, use skeletal objects. */
.float baseframe;	/* See basebone */
.void() customphysics;	/* Called once each physics frame, overriding the entity's .movetype field and associated logic. You'll probably want to use tracebox to move it through the world. Be sure to call .think as appropriate. */
.entity tag_entity;
.float tag_index;
.float skeletonindex;	/* This object serves as a container for the skeletal bone states used to override the animation data. */
.vector colormod;	/* Provides a colour tint for the entity. */
.vector glowmod;
.vector gravitydir;	/* Specifies the direction in which gravity acts. Must be normalised. '0 0 0' also means down. Use '0 0 1' if you want the player to be able to run on ceilings. */
.vector(vector org, vector ang) camera_transform;	/* Provides portal transform information for portal surfaces attached to this entity. Also used to open up pvs in ssqc. */
.float pmove_flags;
.float geomtype;
.float friction;
.float erp;
.float jointtype;
.float mass;
.float bouncefactor;
.float bouncestop;
.float idealpitch;
.float pitch_speed;
.float drawflags;	/* Various flags that affect lighting values and scaling. Typically set to 96 in quake for proper compatibility with DP_QC_SCALE. */
.float abslight;	/* Allows overriding light levels. Use drawflags to state that this field should actually be used. */
.vector color;	/* This affects the colour of realtime lights that were enabled via the pflags field. */
.float light_lev;	/* This is the radius of an entity's light. This is not normally used by the engine, but is used for realtime lights (ones that are enabled with the pflags field). */
.float style;	/* Used by the light util to decide how an entity's light should animate. On an entity with pflags set, this also affects realtime lights. */
.float pflags;	/* Realtime lighting flags */
.float maxspeed;
.entity view2;	/* defines a second viewpoint, typically displayed in a corner of the screen (also punches open pvs). */
.vector movement;	/* These are the directions that the player is currently trying to move in (ie: which +forward/+moveright/+moveup etc buttons they have held), expressed relative to that player's angles. Order is forward, right, up. */
.float vw_index;	/* This acts as a second modelindex, using the same frames etc. */
.entity nodrawtoclient;	/* This entity will not be sent to the player named by this field. They will be invisible and not emit dlights/particles. Does not work in MVD-recorded game. */
.entity drawonlytoclient;	/* This entity will be sent *only* to the player named by this field. To other players they will be invisible and not emit dlights/particles. Does not work in MVD-recorded game. */
.entity viewmodelforclient;	/* This entity will be sent only to the player named by this field, and this entity will be attached to the player's view as an additional weapon model. */
.entity exteriormodeltoclient;	/* This entity will be invisible to the player named by this field, except in mirrors or mirror-like surfaces, where it will be visible as normal. It may still cast shadows as normal, and generate lights+particles, depending on client settings. Does not affect how other players see the entity. */
.float button3;	/* DP_INPUTBUTTONS (note in qw, we set 1 to equal 3, to match zquake/fuhquake/mvdsv) */
.float button4;
.float button5;
.float button6;
.float button7;
.float button8;
.float glow_size;
.float glow_color;
.float glow_trail;
.float traileffectnum;	/* This should be set to the result of particleeffectnum, in order to attach a custom trail effect to an entity as it moves. */
.float emiteffectnum;	/* This should be set to the result of particleeffectnum, in order to continually spawn particles in the direction that this entity faces. */
.float dimension_see;	/* This is the dimension mask (bitfield) that the client is allowed to see. Entities and events not in this dimension mask will be invisible. */
.float dimension_seen;	/* This is the dimension mask (bitfield) that the client is visible within. Clients that cannot see this dimension mask will not see this entity. */
.float dimension_ghost;	/* If this entity is visible only within these dimensions, it will become transparent, as if a ghost. */
.float dimension_ghost_alpha;	/* If this entity is subject to dimension_ghost, this is the scaler for its alpha value. If 0, 0.5 will be used instead. */
.float(entity playerent, float changedflags) SendEntity;	/* Called by the engine whenever an entity needs to be (re)sent to a client's csprogs, either because SendFlags was set or because data was lost. Must write its data to the MSG_ENTITY buffer. Will be called at the engine's leasure. */
.float SendFlags;	/* Indicates that something in the entity has been changed, and that it needs to be updated to all players that can see it. The engine will clear it at some point, with the cleared bits appearing in the 'changedflags' argument of the SendEntity method. */
.float Version;	/* Obsolete, set a SendFlags bit instead. */
.float clientcolors;
.float viewzoom;
.float items2;
.float playerclass;
.float hasted;
.float light_level;	/* Used by hexen2 to indicate the light level where the player is standing. */
.float pvsflags;	/* Reconfigures when the entity is visible to clients */
.float uniquespawnid;	/* Incremented by 1 whenever the entity is respawned. Persists across remove calls, for when the two-second grace period is insufficient. */
.float() customizeentityforclient;	/* Called just before an entity is sent to a client (non-csqc protocol). This gives you a chance to tailor 'self' according to what 'other' should see. */
void URI_Get_Callback(float reqid, float responsecode, string resourcebody);	/* Called as an eventual result of the uri_get builtin. */
void SpectatorConnect();	/* Called when a spectator joins the game. */
void SpectatorDisconnect();	/* Called when a spectator disconnects from the game. */
void SpectatorThink();	/* Called each frame for each spectator. */
void SV_ParseClientCommand(string cmd); 
/* Intercept client 'cmd foo' commands. 
   Self is set to the sending client. 
   Use tokenize() + argv(argno) to access args. 
   Unrecognized commands must be passed to clientcommand builtin. */

void SV_ParseClusterEvent(string dest, string from, string cmd, string info);
/* Cluster mode: handles cross-node events sent via clusterevent on behalf of the named client. */

float SV_ParseConnectionlessPacket(string sender, string body);
/* Handle packets between servers or from client server browsers. 
   Sender is the IP, body is the packet contents. Self is not valid. */

void SV_PausedTic(float pauseduration);
/* Called each frame while the server is paused. 
   pauseduration = time the server has been paused. Self is not valid. */

float SV_ShouldPause(float newstatus);
/* Gives QC a chance to block pause/unpause requests. 
   Return false to ignore the pause. 
   newstatus = 1 if pause is requested. 
   Self = player trying to pause, or world if server-triggered. */

void SV_RunClientCommand();
/* Called when a player movement packet is received. 
   Self = player entity to update. 
   Use input_* globals for movement data. 
   Can call runstandardplayerphysics after modifying inputs. */

void SV_AddDebugPolygons();
/* Called each video frame. Only safe place to call R_BeginPolygon/R_PolygonVertex/R_EndPolygon. 
   For debugging only; breaks in non-local multiplayer. */

void SV_PlayerPhysics();
/* Legacy player input tweaks (prediction may break). 
   If pr_no_playerphysics = 1, this is never called. 
   Mods should prefer SV_RunClientCommand. */

void EndFrame();
/* Called after non-player entities run at the end of the physics frame. 
   Player physics may still occur between EndFrame and BeginFrame. */

string SV_CheckRejectConnection(string addr, string uinfo, string features);
/* Called to allow mods to reject connections based on protocol or client properties. 
   Use infoget to parse uinfo and features. */

string Cef_GeneratePage(string uri, string method, string postdata, __in string requestheaders, __inout string responseheaders);
/* Generate pages for CEF plugin from QC. 
   Headers are key/value pairs separated by newline (use tokenizebyseparator). */

void init(float prevprogs);
/* FTE_MULTIPROGS: Called as soon as a progs is loaded. 
   Entities are not valid yet. Safe place to call addprogs or hook functions in already-loaded modules. */

void initents();
/* FTE_MULTIPROGS: Called after entity fields are finalized. 
   Safe to call spawn(). Called before entity field parsing. Can notify other modules here. */

float parm17, parm18, parm19, parm20, parm21, parm22, parm23, parm24, parm25, parm26, parm27, parm28, parm29, parm30, parm31, parm32;
float parm33, parm34, parm35, parm36, parm37, parm38, parm39, parm40, parm41, parm42, parm43, parm44, parm45, parm46, parm47, parm48;
float parm49, parm50, parm51, parm52, parm53, parm54, parm55, parm56, parm57, parm58, parm59, parm60, parm61, parm62, parm63, parm64;
var float dimension_send;	/* Used by multicast functionality. Multicasts (and related builtins that multicast internally) will only be sent to players where (player.dimension_see & dimension_send) is non-zero. */
//var float dimension_default = 255;
/* Default dimension bitmask */
__used var float physics_mode = 2;	/* 0: original csqc - physics are not run
1: DP-compat. Thinks occur, but not true movetypes.
2: movetypes occur just as they do in ssqc. */
const float TRUE = 1;
const float FALSE = 0;	/* File not found... */
const float M_PI = 3.14159;
const float MOVETYPE_NONE = 0;
const float MOVETYPE_WALK = 3;
const float MOVETYPE_STEP = 4;
const float MOVETYPE_FLY = 5;
const float MOVETYPE_TOSS = 6;
const float MOVETYPE_PUSH = 7;
const float MOVETYPE_NOCLIP = 8;
const float MOVETYPE_FLYMISSILE = 9;
const float MOVETYPE_BOUNCE = 10;
const float MOVETYPE_BOUNCEMISSILE = 11;
const float MOVETYPE_FOLLOW = 12;
const float MOVETYPE_6DOF = 30;	/* A glorified MOVETYPE_FLY. Players using this movetype will get some flightsim-like physics, with fully independant rotations (order-dependant transforms). */
const float MOVETYPE_WALLWALK = 31;	/* Players using this movetype will be able to orient themselves to walls, and then run up them. */
const float MOVETYPE_PHYSICS = 32;	/* Enable the use of ODE physics upon this entity. */
const float SOLID_NOT = 0;
const float SOLID_TRIGGER = 1;
const float SOLID_BBOX = 2;
const float SOLID_SLIDEBOX = 3;
const float SOLID_BSP = 4;	/* Does not collide against other SOLID_BSP entities. Normally paired with MOVETYPE_PUSH. */
const float SOLID_CORPSE = 5;	/* Non-solid to SOLID_SLIDEBOX or other SOLID_CORPSE entities. For hitscan weapons to hit corpses, change the player's .solid value to SOLID_BBOX or so, perform the traceline, then revert the player's .solid value. */
const float SOLID_LADDER = 20;	/* Obsolete and may be removed at some point. Use skin=CONTENT_LADDER and solid_bsp or solid_trigger instead. */
const float SOLID_PORTAL = 21;	/* CSG subtraction volume combined with entity transformations on impact. */
const float SOLID_PHYSICS_BOX = 32;
const float SOLID_PHYSICS_SPHERE = 33;
const float SOLID_PHYSICS_CAPSULE = 34;
const float SOLID_PHYSICS_TRIMESH = 35;
const float SOLID_PHYSICS_CYLINDER = 36;
const float GEOMTYPE_NONE = -1;
const float GEOMTYPE_SOLID = 0;
const float GEOMTYPE_BOX = 1;
const float GEOMTYPE_SPHERE = 2;
const float GEOMTYPE_CAPSULE = 3;
const float GEOMTYPE_TRIMESH = 4;
const float GEOMTYPE_CYLINDER = 5;
const float GEOMTYPE_CAPSULE_X = 6;
const float GEOMTYPE_CAPSULE_Y = 7;
const float GEOMTYPE_CAPSULE_Z = 8;
const float GEOMTYPE_CYLINDER_X = 9;
const float GEOMTYPE_CYLINDER_Y = 10;
const float GEOMTYPE_CYLINDER_Z = 11;
const float JOINTTYPE_FIXED = -1;
const float JOINTTYPE_POINT = 1;
const float JOINTTYPE_HINGE = 2;
const float JOINTTYPE_SLIDER = 3;
const float JOINTTYPE_UNIVERSAL = 4;
const float JOINTTYPE_HINGE2 = 5;
const float DAMAGE_NO = 0;
const float DAMAGE_YES = 1;
const float DAMAGE_AIM = 2;
const float CONTENT_EMPTY = -1;
const float CONTENT_SOLID = -2;
const float CONTENT_WATER = -3;
const float CONTENT_SLIME = -4;
const float CONTENT_LAVA = -5;
const float CONTENT_SKY = -6;
const float CONTENT_LADDER = -16;	/* If this value is assigned to a solid_bsp's .skin field, the entity will become a ladder volume. */
const int CONTENTBIT_NONE = 0x00000000i;
const int CONTENTBIT_SOLID = 0x00000001i;
const int CONTENTBIT_LAVA = 0x00000008i;
const int CONTENTBIT_SLIME = 0x00000010i;
const int CONTENTBIT_WATER = 0x00000020i;
const int CONTENTBIT_FTELADDER = 0x00004000i;
const int CONTENTBIT_PLAYERCLIP = 0x00010000i;
const int CONTENTBIT_MONSTERCLIP = 0x00020000i;
const int CONTENTBIT_BODY = 0x02000000i;
const int CONTENTBIT_CORPSE = 0x04000000i;
const int CONTENTBIT_Q2LADDER = 0x20000000i;	/* Content bit specific to q2bsp */
const int CONTENTBIT_SKY = 0x80000000i;
const int CONTENTBITS_POINTSOLID = CONTENTBIT_SOLID|0x00000002i|CONTENTBIT_BODY;	/* Bits that traceline would normally consider solid */
const int CONTENTBITS_BOXSOLID = CONTENTBIT_SOLID|0x00000002i|CONTENTBIT_BODY|CONTENTBIT_PLAYERCLIP;	/* Bits that tracebox would normally consider solid */
const int CONTENTBITS_FLUID = CONTENTBIT_WATER|CONTENTBIT_SLIME|CONTENTBIT_LAVA|CONTENTBIT_SKY;
const int SPA_POSITION;	/* These SPA_* constants are to specify which attribute is returned by the getsurfacepointattribute builtin */
const int SPA_S_AXIS = 1;
const int SPA_T_AXIS = 2;
const int SPA_R_AXIS = 3;	/* aka: SPA_NORMAL */
const int SPA_TEXCOORDS0 = 4;
const int SPA_LIGHTMAP0_TEXCOORDS = 5;
const int SPA_LIGHTMAP0_COLOR = 6;
const float CHAN_AUTO = 0;	/* The automatic channel, play as many sounds on this channel as you want, and they'll all play, however the other channels will replace each other. */
const float CHAN_WEAPON = 1;
const float CHAN_VOICE = 2;
const float CHAN_ITEM = 3;
const float CHAN_BODY = 4;
const float CHANF_RELIABLE = 8;	/* Only valid if the flags argument is not specified. The sound will be sent reliably, which is important if it is intended to replace looping sounds on doors etc. */
const float SOUNDFLAG_RELIABLE = 1;	/* The sound will be sent reliably, and without regard to phs. */
const float SOUNDFLAG_FORCELOOP = 2;	/* The sound will restart once it reaches the end of the sample. */
const float SOUNDFLAG_NOREVERB = 32;	/* Disables the use of underwater/reverb effects on this sound effect. */
const float SOUNDFLAG_FOLLOW = 64;	/* The sound's origin will updated to follow the emitting entity. */
const float SOUNDFLAG_UNICAST = 256;	/* The sound will be heard only by the player specified by msg_entity. */
const float SOUNDFLAG_SENDVELOCITY = 512;	/* The entity's current velocity will be sent to the client, only useful if doppler is enabled. */
const float ATTN_NONE = 0;	/* Sounds with this attenuation can be heard throughout the map */
const float ATTN_NORM = 1;	/* Standard attenuation */
const float ATTN_IDLE = 2;	/* Extra attenuation so that sounds don't travel too far. */
const float ATTN_STATIC = 3;	/* Even more attenuation to avoid torches drowing out everything else throughout the map. */
const float SVC_CGAMEPACKET = 83;	/* Direct ssqc->csqc message. Must only be multicast. The data triggers a CSQC_Parse_Event call in the csqc for the csqc to read the contents. The server *may* insert length information for clients connected via proxies which are not able to cope with custom csqc payloads. This should only ever be used in conjunction with the MSG_MULTICAST destination. */
const float MSG_BROADCAST = 0;	/* The byte(s) will be unreliably sent to all players. MSG_ constants are valid arguments to the Write* builtin family. */
const float MSG_ONE = 1;	/* The byte(s) will be reliably sent to the player specified in the msg_entity global. WARNING: in quakeworld servers without network preparsing enabled, this can result in illegible server messages (due to individual reliable messages being split between multiple backbuffers/packets). NQ has larger reliable buffers which avoids this issue, but still kicks the client. */
const float MSG_ALL = 2;	/* The byte(s) will be reliably sent to all players. */
const float MSG_INIT = 3;	/* The byte(s) will be written into the signon buffer. Clients will see these messages when they connect later. This buffer is only flushed on map changes, so spamming it _WILL_ result in overflows. */
const float MSG_MULTICAST = 4;	/* The byte(s) will be written into the multicast buffer for more selective sending. Messages sent this way will never be split across packets, and using this for csqc-only messages will not break protocol translation. */
const float MSG_ENTITY = 5;	/* The byte(s) will be written into the entity buffer. This is a special value used only inside 'SendEntity' functions. */
const float MULTICAST_ALL = 0;	/* The multicast message is unreliably sent to all players. MULTICAST_ constants are valid arguments for the multicast builtin, which ignores the specified origin when given this constant. */
const float MULTICAST_PHS = 1;	/* The multicast message is unreliably sent to only players that can potentially hear the specified origin. Its quite loose. */
const float MULTICAST_PVS = 2;	/* The multicast message is unreliably sent to only players that can potentially see the specified origin. */
const float MULTICAST_ONE = 6;	/* The multicast message is unreliably sent to the player specified in the msg_entity global. The specified origin is ignored. */
const float MULTICAST_ALL_R = 3;	/* The multicast message is reliably sent to all players. The specified origin is ignored. */
const float MULTICAST_PHS_R = 4;	/* The multicast message is reliably sent to only players that can potentially hear the specified origin. Players might still not receive it if they are out of range. */
const float MULTICAST_PVS_R = 5;	/* The multicast message is reliably sent to only players that can potentially see the specified origin. Players might still not receive it if they cannot see the event. */
const float MULTICAST_ONE_R = 7;	/* The multicast message is reliably sent to the player specified in the msg_entity global. The specified origin is ignored */
const float PRINT_LOW = 0;
const float PRINT_MEDIUM = 1;
const float PRINT_HIGH = 2;
const float PRINT_CHAT = 3;
const float PVSF_NORMALPVS = 0;	/* Filter first by PVS, then filter this entity using tracelines if sv_cullentities is enabled. */
const float PVSF_NOTRACECHECK = 1;	/* Filter strictly by PVS. */
const float PVSF_USEPHS = 2;	/* Send if we're close enough to be able to hear this entity. */
const float PVSF_IGNOREPVS = 3;	/* Ignores pvs. This entity is visible whereever you are on the map. */
const float PVSF_NOREMOVE = 128;	/* Once visible to a client, this entity will remain visible. This can be useful for csqc and corpses. */
const string INFOKEY_P_IP = "ip";	/* The apparent ip address of the client. This may be a proxy's ip address. */
const string INFOKEY_P_REALIP = "realip";	/* If sv_getrealip is set, this gives the ip as determine using that algorithm. */
const string INFOKEY_P_CSQCACTIVE = "csqcactive";	/* Client has csqc enabled. CSQC ents etc will be sent to this player. */
const string INFOKEY_P_SVPING = "svping";
const string INFOKEY_P_GUID = "guid";	/* Some hash string which should be reasonably unique to this player's quake installation. */
const string INFOKEY_P_CHALLENGE = "challenge";
const string INFOKEY_P_USERID = "*userid";
const string INFOKEY_P_DOWNLOADPCT = "download";	/* The client's download percentage for the current file. Additional files are not known. */
const string INFOKEY_P_TRUSTLEVEL = "trustlevel";
const string INFOKEY_P_PROTOCOL = "protocol";	/* The network protocol the client is using to connect to the server. */
const string INFOKEY_P_VIP = "*VIP";	/* 1 if the player has the VIP 'penalty'. */
const string INFOKEY_P_ISMUTED = "*ismuted";	/* 1 if the player has the 'mute' penalty and is not allowed to use the say/say_team commands. */
const string INFOKEY_P_ISDEAF = "*isdeaf";	/* 1 if the player has the 'deaf' penalty and cannot see other people's say/say_team commands. */
const string INFOKEY_P_ISCRIPPLED = "*ismuted";	/* 1 if the player has the cripple penalty, and their movement values are ignored (.movement is locked to 0). */
const string INFOKEY_P_ISCUFFED = "*ismuted";	/* 1 if the player has the cuff penalty, and is unable to attack or use impulses(.button0 and .impulse fields are locked to 0). */
const string INFOKEY_P_ISLAGGED = "*ismuted";	/* 1 if the player has the fakelag penalty and has an extra 200ms of lag. */
const string INFOKEY_P_PING = "ping";	/* The player's ping time, in milliseconds. */
const string INFOKEY_P_NAME = "name";	/* The player's name. */
const string INFOKEY_P_SPECTATOR = "*spectator";	/* Whether the player is a spectator or not. */
const string INFOKEY_P_TOPCOLOR = "topcolor";	/* The player's upper/shirt colour (palette index). */
const string INFOKEY_P_BOTTOMCOLOR = "bottomcolor";	/* The player's lower/pants/trouser colour (palette index). */
const float STUFFCMD_IGNOREINDEMO = 1;	/* This stuffcmd will NOT be written to mvds/qtv. */
const float STUFFCMD_DEMOONLY = 2;	/* This stuffcmd will ONLY be written into mvds/qtv streams. */
const float STUFFCMD_BROADCAST = 4;	/* The stuffcmd will be broadcast server-wide (according to the mvd filters). */
const float STUFFCMD_UNRELIABLE = 8;	/* The stuffcmd might not arrive. It might also get there faster than ones sent over the reliable channel. */
const float FL_FLY = 1;
const float FL_SWIM = 2;
const float FL_CLIENT = 8;
const float FL_INWATER = 16;
const float FL_MONSTER = 32;
const float FL_GODMODE = 64;
const float FL_NOTARGET = 128;
const float FL_ITEM = 256;
const float FL_ONGROUND = 512;
const float FL_PARTIALGROUND = 1024;
const float FL_WATERJUMP = 2048;
const float FL_FINDABLE_NONSOLID = 16384;	/* Allows this entity to be found with findradius */
const float FL_LAGGEDMOVE = 65536;	/* Enables anti-lag on rockets etc. */
const float MOVE_NORMAL = 0;
const float MOVE_NOMONSTERS = 1;	/* The trace will ignore all non-solid_bsp entities. */
const float MOVE_MISSILE = 2;	/* The trace will use a bbox size of +/- 15 against entities with FL_MONSTER set. */
const float MOVE_HITMODEL = 4;	/* Traces will impact the actual mesh of the model instead of merely their bounding box. Should generally only be used for tracelines. Note that this flag is unreliable as an object can animate through projectiles. The bounding box MUST be set to completely encompass the entity or those extra areas will be non-solid (leaving a hole for things to go through). */
const float MOVE_TRIGGERS = 16;	/* This trace type will impact only triggers. It will ignore non-solid entities. */
const float MOVE_EVERYTHING = 32;	/* This type of trace will hit solids and triggers alike. Even non-solid entities. */
const float MOVE_LAGGED = 64;	/* Will use antilag based upon the player's latency. Traces will be performed against old positions for entities instead of their current origin. */
const float MOVE_ENTCHAIN = 128;	/* Returns a list of entities impacted via the trace_ent.chain field */
const float MOVE_OTHERONLY = 256;	/* Traces that use this trace type will collide against *only* the entity specified via the 'other' global, and will ignore all owner/solid_not/dimension etc rules, they will still adhere to contents and bsp/bbox rules though. */
const float RESTYPE_MODEL = 0;	/* RESTYPE_* constants are used as arguments with the resourcestatus builtin. */
const float RESTYPE_SOUND = 1;	/* precache_sound */
const float RESTYPE_PARTICLE = 2;	/* particleeffectnum */
const float RESSTATE_NOTKNOWN = 0;	/* RESSTATE_* constants are return values from the resourcestatus builtin. The engine doesn't know about the resource if it is in this state. This means you will need to precache it. Attempting to use it anyway may result in warnings, errors, or silently succeed, depending on engine version and resource type. */
const float RESSTATE_NOTLOADED = 1;	/* The resource was precached, but has been flushed and there has not been an attempt to reload it. If you use the resource normally, chances are it'll be loaded but at the cost of a stall. */
const float RESSTATE_LOADING = 2;	/* Resources in this this state are queued for loading, and will be loaded at the engine's convienience. If you attempt to query the resource now, the engine will stall until the result is available. sounds in this state may be delayed, while models/pics/shaders may be invisible. */
const float RESSTATE_FAILED = 3;	/* Resources in this state are unusable/could not be loaded. You will get placeholders or dummy results. Queries will not stall the engine. The engine may display placeholder content. */
const float RESSTATE_LOADED = 4;	/* Resources in this state are finally usable, everything will work okay. Hurrah. Queries will not stall the engine. */
const float EF_BRIGHTFIELD = 1;
const float EF_BRIGHTLIGHT = 4;
const float EF_DIMLIGHT = 8;
const float EF_FLAG1 = 16;
const float EF_FLAG2 = 32;
const float EF_BLUE = 64;	/* A blue glow */
const float EF_RED = 128;	/* A red glow */
const float EF_GREEN = 262144;	/* A green glow */
const float EF_FULLBRIGHT = 512;	/* This entity will ignore lighting */
const float EF_NOSHADOW = 4096;	/* This entity will not cast shadows */
const float EF_NODEPTHTEST = 8192;	/* This entity will be drawn over the top of other things that are closer. */
const float EF_NOMODELFLAGS = 8388608;	/* Surpresses the normal flags specified in the model. */
const float MF_ROCKET = 1;
const float MF_GRENADE = 2;
const float MF_GIB = 4;	/* Regular blood trail */
const float MF_ROTATE = 8;
const float MF_TRACER = 16;	/* AKA: green scrag trail */
const float MF_ZOMGIB = 32;	/* Dark blood trail */
const float MF_TRACER2 = 64;	/* AKA: hellknight projectile trail */
const float MF_TRACER3 = 128;	/* AKA: purple vore trail */
const float SL_ORG_TL = 20;	/* Used with showpic etc, specifies that the x+y values are relative to the top-left of the screen */
const float SL_ORG_TR = 21;
const float SL_ORG_BL = 22;
const float SL_ORG_BR = 23;
const float SL_ORG_MM = 24;
const float SL_ORG_TM = 25;
const float SL_ORG_BM = 26;
const float SL_ORG_ML = 27;
const float SL_ORG_MR = 28;
const float PFLAGS_NOSHADOW = 1;	/* Associated RT lights attached will not cast shadows, making them significantly faster to draw. */
const float PFLAGS_CORONA = 2;	/* Enables support of coronas on the associated rtlights. */
const float PFLAGS_FULLDYNAMIC = 128;	/* When set in self.pflags, enables fully-customised dynamic lights. Custom rtlight information is not otherwise used. */
const float EV_STRING = 1;
const float EV_FLOAT = 2;
const float EV_VECTOR = 3;
const float EV_ENTITY = 4;
const float EV_FIELD = 5;
const float EV_FUNCTION = 6;
const float EV_POINTER = 7;
const float EV_INTEGER = 8;
const float EV_VARIANT = 9;
hashtable gamestate;	/* Special hash table index for hash_add and hash_get. Entries in this table will persist over map changes (and doesn't need to be created/deleted). */
const float HASH_REPLACE = 256;	/* Used with hash_add. Attempts to remove the old value instead of adding two values for a single key. */
const float HASH_ADD = 512;	/* Used with hash_add. The new entry will be inserted in addition to the existing entry. */
const float STAT_USER = 32;	/* Custom user stats start here (lower values are reserved for engine use). */
const float CLIENTTYPE_DISCONNECTED = 0;	/* Return value from clienttype() builtin. This entity is a player slot that is currently empty. */
const float CLIENTTYPE_REAL = 1;	/* This is a real player, and not a bot. */
const float CLIENTTYPE_BOT = 2;	/* This player slot does not correlate to a real player, any messages sent to this client will be ignored. */
const float CLIENTTYPE_NOTACLIENT = 3;	/* This entity is not even a player slot. This is typically an error condition. */
const float FILE_READ = 0;	/* The file may be read via fgets to read a single line at a time. */
const float FILE_APPEND = 1;	/* Like FILE_WRITE, but writing starts at the end of the file. */
const float FILE_WRITE = 2;	/* fputs will be used to write to the file. */
const float FILE_READNL = 4;	/* Like FILE_READ, except newlines are not special. fgets reads the entire file into a tempstring. */
const float FILE_MMAP_READ = 5;	/* The file will be loaded into memory. fgets returns a pointer to the first byte (and will always return the same value for this file). Cast this to your datatype. */
const float FILE_MMAP_RW = 6;	/* Like FILE_MMAP_READ, except any changes to the data will be written back to disk once the file is closed. */
void makevectors(vector vang) = #1; /*
		Takes an angle vector (pitch,yaw,roll) (+x=DOWN). Writes its results into v_forward, v_right, v_up vectors. */

void setorigin(entity e, vector o) = #2; /*
		Changes e's origin to be equal to o. Also relinks collision state (as well as setting absmin+absmax), which is required after changing .solid */

void setmodel(entity e, string m) = #3; /*
		Looks up m in the model precache list, and sets both e.model and e.modelindex to match. BSP models will set e.mins and e.maxs accordingly, other models depend upon the value of sv_gameplayfix_setmodelrealbox - for compatibility you should always call setsize after all pickups or non-bsp models. Also relinks collision state. */

void setsize(entity e, vector min, vector max) = #4; /*
		Sets the e's mins and maxs fields. Also relinks collision state, which sets absmin and absmax too. */

void breakpoint() = #6; /*
		Trigger a debugging event. FTE will break into the qc debugger. Other engines may crash with a debug execption. */

float random() = #7; /*
		Returns a random value between 0 and 1. Be warned, this builtin can return 1 in most engines, which can break arrays. */

void sound(entity e, float chan, string samp, float vol, float atten, optional float speedpct, optional float flags, optional float timeofs) = #8; /*
		Starts a sound centered upon the given entity.
		chan is the entity sound channel to use, channel 0 will allow you to mix many samples at once, others will replace the old sample
		'samp' must have been precached first
		if specified, 'speedpct' should normally be around 100 (or =0), 200 for double speed or 50 for half speed.
		If flags is specified, the reliable flag in the channels argument is used for additional channels. Flags should be made from SOUNDFLAG_* constants
		timeofs should be negative in order to provide a delay before the sound actually starts. */

vector normalize(vector v) = #9; /*
		Shorten or lengthen a direction vector such that it is only one quake unit long. */

void error(string e) = #10; /*
		Ends the game with an easily readable error message. */

void objerror(string e) = #11; /*
		Displays a non-fatal easily readable error message concerning the self entity, including a field dump. self will be removed! */

float vlen(vector v) = #12; /*
		Returns the square root of the dotproduct of a vector with itself. Or in other words the length of a distance vector, in quake units. */

float vectoyaw(vector v, optional entity reference) = #13; /*
		Given a direction vector, returns the yaw angle in which that direction vector points. If an entity is passed, the yaw angle will be relative to that entity's gravity direction. */

entity spawn() = #14; /*
		Adds a brand new entity into the world! Hurrah, you're now a parent! */

void remove(entity e) = #15; /*
		Destroys the given entity and clears some limited fields (including model, modelindex, solid, classname). Any references to the entity following the call are an error. After two seconds, the entity will be reused, in the interim you can unfortunatly still read its fields to see if the reference is no longer valid. */

void traceline(vector v1, vector v2, float flags, entity ent) = #16; /*
		Traces a thin line through the world from v1 towards v2.
		Will not collide with ent, ent.owner, or any entity who's owner field refers to ent.
		The passed entity will also be used to determine whether to use a capsule trace, the contents that the trace should impact, and a couple of other extra fields that define the trace.
		There are no side effects beyond the trace_* globals being written.
		flags&MOVE_NOMONSTERS will not impact on non-bsp entities.
		flags&MOVE_MISSILE will impact with increased size.
		flags&MOVE_HITMODEL will impact upon model meshes, instead of their bounding boxes.
		flags&MOVE_TRIGGERS will also stop on triggers
		flags&MOVE_EVERYTHING will stop if it hits anything, even non-solid entities.
		flags&MOVE_LAGGED will backdate entity positions for the purposes of this builtin according to the indicated player ent's latency, to provide lag compensation. */

entity checkclient() = #17; /*
		Returns one of the player entities. The returned player will change periodically. */

entity find(entity start, .string fld, string match) = #18; /*
		Scan for the next entity with a given field set to the given 'match' value. start should be either world, or the previous entity that was found. Returns world on failure/if there are no more.
		If you have many many entities then you may find that hashtables will give more performance (but requires extra upkeep). */

string precache_sound(string s) = #19; /*
		Precaches a sound, making it known to clients and loading it from disk. This builtin (strongly) should be called during spawn functions. This builtin must be called for the sound before the sound builtin is called, or it might not even be heard. */

string precache_model(string s) = #20; /*
		Precaches a model, making it known to clients and loading it from disk if it has a .bsp extension. This builtin (strongly) should be called during spawn functions. This must be called for each model name before setmodel may use that model name.
		Modelindicies precached in SSQC will always be positive. CSQC precaches will be negative if they are not also on the server. */

void stuffcmd(entity client, string s) = #21; /*
		Sends a console command (or cvar) to the client, where it will be executed. Different clients support different commands. Do NOT forget the final \n.
		This builtin is generally considered evil. */

void stuffcmdflags(entity client, float flags, string s) = #0:stuffcmdflags; /* Part of FTE_QC_STUFFCMDFLAGS
		Sends a console command (or cvar) to the client, where it will be executed. Different clients support different commands. Do NOT forget the final \n.
		This (just as evil) variant allows specifying some flags too. See the STUFFCMD_* constants. */

entity findradius(vector org, float rad, optional .entity chainfield) = #22; /*
		Finds all entities within a distance of the 'org' specified. One entity is returned directly, while other entities are returned via that entity's .chain field. */

void bprint(float msglvl, string s, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7) = #23; /*
		QW: Concatenates all string arguments, and prints the messsage on the console of only all clients who's 'msg' infokey is set lower or equal to the supplied 'msglvl' argument. */

void sprint(entity client, float msglvl, string s, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6) = #24; /*
		QW: Concatenates all string arguments, and prints the messsage on the named client's console, but only if that client's 'msg' infokey is set lower or equal to the supplied 'msglvl' argument. */

void dprint(string s, ...) = #25; /*
		QW: Unconditionally prints the given message on the server's console.  Arguments will be concatenated into a single message. */

string ftos(float val) = #26; /*
		Returns a tempstring containing a representation of the given float. Precision depends upon engine. */

string vtos(vector val) = #27; /*
		Returns a tempstring containing a representation of the given vector. Precision depends upon engine. */

void coredump() = #28; /*
		Writes out a coredump. This contains stack, globals, and field info for all ents. This can be handy for debugging. */

void traceon() = #29; /*
		Enables tracing. This may be spammy, slow, and stuff. Set debugger 1 in order to use fte's qc debugger. */

void traceoff() = #30; /*
		Disables tracing again. */

void eprint(entity e) = #31; /*
		Debugging builtin that prints all fields of the given entity to the console. */

float walkmove(float yaw, float dist, optional float settraceglobals) = #32; /*
		Attempt to walk the entity at a given angle for a given distance.
		if settraceglobals is set, the trace_* globals will be set, showing the results of the movement.
		This function will trigger touch events. */

float droptofloor() = #34; /*
		Instantly moves the entity downwards until it hits the ground. If the entity is in solid or would need to drop more than 'pr_droptofloorunits' quake units, its position will be considered invalid and the builtin will abort, returning FALSE, otherwise TRUE. */

void lightstyle(float lightstyle, string stylestring, optional vector rgb) = #35; /*
		Specifies an auto-animating string that specifies the light intensity for entities using that lightstyle.
		a is off, z is fully lit. Should be lower case only.
		rgb will recolour all lights using that lightstyle. */

float rint(float) = #36; /*
		Rounds the given float up or down to the closest integeral value. X.5 rounds away from 0 */

float floor(float) = #37; /*
		Rounds the given float downwards, even when negative. */

float ceil(float) = #38; /*
		Rounds the given float upwards, even when negative. */

float checkbottom(entity ent) = #40; /*
		Expensive checks to ensure that the entity is actually sitting on something solid, returns true if it is. */

float pointcontents(vector pos) = #41; /*
		Checks the given point to see what is there. Returns one of the SOLID_* constants. Just because a spot is empty does not mean that the player can stand there due to the size of the player - use tracebox for such tests. */

float fabs(float) = #43; /*
		Removes the sign of the float, making it positive if it is negative. */

vector aim(entity player, float missilespeed) = #44; /*
		Returns a direction vector (specifically v_forward on error). This builtin attempts to guess what pitch angle to fire projectiles at for people that don't know about mouselook. Does not affect yaw angles. */

float cvar(string) = #45; /*
		Returns the numeric value of the named cvar */

void localcmd(string, ...) = #46; /*
		Adds the string to the console command queue. Commands will not be executed immediately, but rather at the start of the following frame. */

entity nextent(entity) = #47; /*
		Returns the following entity. Skips over removed entities. Returns world when passed the last valid entity. */

void particle(vector pos, vector dir, float colour, float count) = #48; /*
		Spawn 'count' particles around 'pos' moving in the direction 'dir', with a palette colour index between 'colour' and 'colour+8'. */

#define ChangeYaw changeyaw
void changeyaw() = #49; /*
		Changes the self.angles_y field towards self.ideal_yaw by up to self.yaw_speed. */

vector vectoangles(vector fwd, optional vector up) = #51; /*
		Returns the angles (+x=UP) required to orient an entity to look in the given direction. The 'up' argument is required if you wish to set a roll angle, otherwise it will be limited to just monster-style turning. */

void WriteByte(float to, float val) = #52; /*
		Writes a single byte into a network message buffer. Typically you will find a more correct alternative to writing arbitary data. 'to' should be one of the MSG_* constants. MSG_ONE must have msg_entity set first. */

void WriteChar(float to, float val) = #53;
void WriteShort(float to, float val) = #54;
void WriteLong(float to, float val) = #55;
void WriteCoord(float to, float val) = #56;
void WriteAngle(float to, float val) = #57;
void WriteString(float to, string val) = #58;
void WriteEntity(float to, entity val) = #59;
float sin(float angle) = #60; /* Part of DP_QC_SINCOSSQRTPOW
		Forgive me father, for I have trigonometry homework. */

float cos(float angle) = #61; /* Part of DP_QC_SINCOSSQRTPOW */
float sqrt(float value) = #62; /* Part of DP_QC_SINCOSSQRTPOW */
float modulo(float a, float n) = #0:modulo;
void changepitch(entity ent) = #63; /* Part of DP_QC_CHANGEPITCH */
void tracetoss(entity ent, entity ignore) = #64;
string etos(entity ent) = #65; /* Part of DP_QC_ETOS */
void movetogoal(float step) = #67; /*
    Runs lots and lots of fancy logic in order to try to step the entity the specified distance towards its goalentity. */
string precache_file(string s) = #68; /*
    This builtin does nothing. It was used only as a hint for pak generation. */
void makestatic(entity e) = #69; /*
    Sends a copy of the entity's renderable fields to all clients, and REMOVES the entity, preventing further changes. This means it will be unmutable and non-solid. */
void changelevel(string mapname, optional string newmapstartspot) = #70; /*
    Attempts to change the map to the named map. If 'newmapstartspot' is specified, the state of the current map will be preserved, and the argument will be passed to the next map in the 'startspot' global, and the next map will be loaded from archived state if it was previously visited. If not specified, all archived map states will be purged. */
void cvar_set(string cvarname, string valuetoset) = #72; /*
    Instantly sets a cvar to the given string value. */
void centerprint(entity ent, string text, optional string text2, optional string text3, optional string text4, optional string text5, optional string text6, optional string text7) = #73;
void ambientsound(vector pos, string samp, float vol, float atten) = #74;
string precache_model2(string str) = #75;
string precache_sound2(string str) = #76;
string precache_file2(string str) = #77;
void setspawnparms(entity player) = #78;
void logfrag(entity killer, entity killee) = #79; /* Part of QW_ENGINE */
string infokey(entity e, string key) = #80; /* Part of FTE_QC_INFOKEY, QW_ENGINE */
float infokeyf(entity e, string key) = #0:infokeyf; /*
    Identical to regular infokey, except returns a float. */
float stof(string s) = #81; /* Part of FRIK_FILE, FTE_QC_INFOKEY, FTE_STRINGS, QW_ENGINE, ZQ_QC_STRINGS */
void multicast(vector where, float set) = #82; /* Part of FTE_QC_MULTICAST */
void redirectcmd(entity to, string str) = #101; /* Part of ??MVDSV_BUILTINS */
string getlightstyle(float style, optional __out vector rgb) = #0:getlightstyle;
vector getlightstylergb(float style) = #0:getlightstylergb;
void lightstylestatic(float style, float val, optional vector rgb) = #5;
void tracebox(vector start, vector mins, vector maxs, vector end, float nomonsters, entity ent) = #90; /* Part of DP_QC_TRACEBOX */
vector randomvec() = #91; /* Part of DP_QC_RANDOMVEC */
vector getlight(vector org) = #92;
float registercvar(string cvarname, string defaultvalue) = #93; /* Part of DP_REGISTERCVAR */
float min(float a, float b, ...) = #94; /* Part of DP_QC_MINMAXBOUND */
float max(float a, float b, ...) = #95; /* Part of DP_QC_MINMAXBOUND */
float bound(float minimum, float val, float maximum) = #96; /* Part of DP_QC_MINMAXBOUND */
float pow(float value, float exp) = #97; /* Part of DP_QC_SINCOSSQRTPOW */
float logarithm(float v, optional float base) = #0:logarithm; /*
    Determines the logarithm of the input value according to the specified base. This can be used to calculate how much something was shifted by. */
entity findfloat(entity start, .__variant fld, __variant match) = #98; /* Part of DP_QC_FINDFLOAT */
float checkextension(string extname) = #99; /*
    Checks for an extension by its name (eg: checkextension("FRIK_FILE") says that its okay to go ahead and use strcat).
    Use cvar("pr_checkextension") to see if this builtin exists. */
float checkbuiltin(__variant funcref) = #0:checkbuiltin; /*
    Checks to see if the specified builtin is supported/mapped. */
float builtin_find(string builtinname) = #100;
float anglemod(float value) = #102;
void showpic(string slot, string picname, float x, float y, float zone, optional entity player) = #104; /* Part of TEI_SHOWLMP2 */
void hidepic(string slot, optional entity player) = #105; /* Part of TEI_SHOWLMP2 */
void movepic(string slot, float x, float y, float zone, optional entity player) = #106; /* Part of TEI_SHOWLMP2 */
void changepic(string slot, string picname, optional entity player) = #107; /* Part of TEI_SHOWLMP2 */
filestream fopen(string filename, float mode, optional float mmapminsize) = #110; /* Part of FRIK_FILE */
void fclose(filestream fhandle) = #111; /* Part of FRIK_FILE */
string fgets(filestream fhandle) = #112; /* Part of FRIK_FILE */
void fputs(filestream fhandle, string s, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7) = #113; /* Part of FRIK_FILE */
int fread(filestream fhandle, void *ptr, int size) = #0:fread; /* Part of FTE_QC_FILE_BINARY */
int fwrite(filestream fhandle, void *ptr, int size) = #0:fwrite; /* Part of FTE_QC_FILE_BINARY */
int fseek(filestream fhandle, optional int newoffset) = #0:fseek; /* Part of FTE_QC_FILE_BINARY */
int fsize(filestream fhandle, optional int newsize) = #0:fsize; /* Part of FTE_QC_FILE_BINARY */
float strlen(string s) = #114; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS */
string strcat(string s1, optional string s2, optional string s3, optional string s4, optional string s5, optional string s6, optional string s7, optional string s8) = #115; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS */
string substring(string s, float start, float length) = #116; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS */
vector stov(string s) = #117; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS */
string strzone(string s, ...) = #118; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS */
void strunzone(string s) = #119; /* Part of FRIK_FILE, FTE_STRINGS, ZQ_QC_STRINGS */
void cvar_setf(string cvar, float val) = #176;
void localsound(string soundname, optional float channel, optional float volume) = #177; /* Part of FTE_QC_NPCCHAT */
float getmodelindex(string modelname, optional float queryonly) = #200; /* Part of FTE_QC_NPCCHAT */
__variant externcall(float prnum, string funcname, ...) = #201; /* Part of FTE_MULTIPROGS */
float addprogs(string progsname) = #202; /* Part of FTE_MULTIPROGS */
__variant externvalue(float prnum, string varname) = #203; /* Part of FTE_MULTIPROGS */
void externset(float prnum, __variant newval, string varname) = #204; /* Part of FTE_MULTIPROGS */
void openportal(entity portal, float state) = #207; /* Part of FTE_MULTIPROGS */
float RegisterTempEnt(float attributes, string effectname, ...) = #208; /* Part of FTE_PEXT_CUSTOMTENTS */
void CustomTempEnt(float type, vector pos, ...) = #209; /* Part of FTE_PEXT_CUSTOMTENTS */
float fork(optional float sleeptime) = #210; /* Part of FTE_MULTITHREADED */
void abort(optional __variant ret) = #211; /* Part of FTE_MULTITHREADED */
void sleep(float sleeptime) = #212; /* Part of FTE_MULTITHREADED */
void forceinfokey(entity player, string key, string value) = #213; /* Part of FTE_FORCEINFOKEY */
void chat(string filename, float starttag, entity edict) = #214; /* Part of FTE_QC_NPCCHAT */
void particle2(vector org, vector dmin, vector dmax, float colour, float effect, float count) = #215; /* Part of FTE_HEXEN2 */
void particle3(vector org, vector box, float colour, float effect, float count) = #216; /* Part of FTE_HEXEN2 */
void particle4(vector org, float radius, float colour, float effect, float count) = #217; /* Part of FTE_HEXEN2 */
float bitshift(float number, float quantity) = #218; /* Part of EXT_BITSHIFT */
void te_lightningblood(vector pos) = #219; /* Part of FTE_TE_STANDARDEFFECTBUILTINS */
float strstrofs(string s1, string sub, optional float startidx) = #221; /* Part of FTE_STRINGS */
float str2chr(string str, float index) = #222; /* Part of FTE_STRINGS */
string chr2str(float chr, ...) = #223; /* Part of FTE_STRINGS */
string strconv(float ccase, float redalpha, float redchars, string str, ...) = #224; /* Part of FTE_STRINGS */

string(float pad, string str1, ...) strpad = #225; /* Part of FTE_STRINGS
		Pads the string with spaces, to ensure its a specific length (so long as a fixed-width font is used, anyway). If pad is negative, the spaces are added on the left. If positive the padding is on the right. */

string(infostring old, string key, string value) infoadd = #226; /* Part of FTE_STRINGS
		Returns a new tempstring infostring with the named value changed (or added if it was previously unspecified). Key and value may not contain the \ character. */

string(infostring info, string key) infoget = #227; /* Part of FTE_STRINGS
		Reads a named value from an infostring. The returned value is a tempstring */

#define strcmp strncmp
float strncmp(string s1, string s2, optional float len, optional float s1ofs, optional float s2ofs) = #228; /* Part of FTE_STRINGS
    Compares up to 'len' chars in the two strings. s1ofs allows you to treat s2 as a substring to compare against, or should be 0.
    Returns 0 if the two strings are equal, a negative value if s1 appears numerically lower, and positive if s1 appears numerically higher. */

float strcasecmp(string s1, string s2) = #229; /* Part of FTE_STRINGS
    Compares the two strings without case sensitivity.
    Returns 0 if they are equal. The sign of the return value may be significant, but should not be depended upon. */

float strncasecmp(string s1, string s2, float len, optional float s1ofs, optional float s2ofs) = #230; /* Part of FTE_STRINGS
    Compares up to 'len' chars in the two strings without case sensitivity. s1ofs allows you to treat s2 as a substring to compare against, or should be 0.
    Returns 0 if they are equal. The sign of the return value may be significant, but should not be depended upon. */

string strtrim(string s) = #0:strtrim; /*
    Trims the whitespace from the start+end of the string. */

void calltimeofday() = #231; /* Part of FTE_CALLTIMEOFDAY
    Asks the engine to instantly call the qc's 'timeofday' function, before returning. For compatibility with mvdsv.
    timeofday should have the prototype: void(float secs, float mins, float hour, float day, float mon, float year, string strvalue)
    The strftime builtin is more versatile and less weird. */

void clientstat(float num, float type, .__variant fld) = #232; /*
    Specifies what data to use in order to send various stats, in a client-specific way.
    'num' should be a value between 32 and 127, other values are reserved.
    'type' must be set to one of the EV_* constants, one of EV_FLOAT, EV_STRING, EV_INTEGER, EV_ENTITY.
    fld must be a reference to the field used, each player will be sent only their own copy of these fields. */

void globalstat(float num, float type, string name) = #233; /*
    Specifies what data to use in order to send various stats, in a non-client-specific way. num and type are as in clientstat, name however, is the name of the global to read in the form of a string (pass "foo"). */

void pointerstat(float num, float type, __variant *address) = #0:pointerstat; /*
    Specifies what data to use in order to send various stats, in a non-client-specific way. num and type are as in clientstat, address however, is the address of the variable you would like to use (pass &foo). */

float isbackbuffered(entity player) = #234; /* Part of FTE_ISBACKBUFFERED
    Returns if the given player's network buffer will take multiple network frames in order to clear. If this builtin returns non-zero, you should delay or reduce the amount of reliable (and also unreliable) data that you are sending to that client. */

void rotatevectorsbyangle(vector angle) = #235; /*
    rotates the v_forward,v_right,v_up matrix by the specified angles. */

void rotatevectorsbyvectors(vector fwd, vector right, vector up) = #236;

float skinforname(float mdlindex, string skinname) = #237;

void te_bloodqw(vector org, optional float count) = #239; /* Part of FTE_TE_STANDARDEFFECTBUILTINS*/

void te_muzzleflash(entity ent) = #0:te_muzzleflash;

float checkpvs(vector viewpos, entity entity) = #240; /* Part of FTE_QC_CHECKPVS*/

entity matchclientname(string match, optional float matchnum) = #241; /* Part of FTE_QC_MATCHCLIENTNAME*/

void sendpacket(string destaddress, string content) = #242; /* Part of FTE_QC_SENDPACKET*/

float mod(float dividend, float divisor) = #245;

float sqlconnect(optional string host, optional string user, optional string pass, optional string defaultdb, optional string driver) = #250; /* Part of FTE_SQL*/

void sqldisconnect(float serveridx) = #251; /* Part of FTE_SQL*/

float sqlopenquery(float serveridx, void(float serveridx, float queryidx, float rows, float columns, float eof, float firstrow) callback, float querytype, string query) = #252; /* Part of FTE_SQL*/

void sqlclosequery(float serveridx, float queryidx) = #253; /* Part of FTE_SQL*/

string sqlreadfield(float serveridx, float queryidx, float row, float column) = #254; /* Part of FTE_SQL*/

string sqlerror(float serveridx, optional float queryidx) = #255; /* Part of FTE_SQL*/

string sqlescape(float serveridx, string data) = #256; /* Part of FTE_SQL*/

string sqlversion(float serveridx) = #257; /* Part of FTE_SQL*/

float sqlreadfloat(float serveridx, float queryidx, float row, float column) = #258; /* Part of FTE_SQL*/

int sqlreadblob(float serveridx, float queryidx, float row, float column, __variant *ptr, int maxsize) = #0:sqlreadblob;

string sqlescapeblob(float serveridx, __variant *ptr, int maxsize) = #0:sqlescapeblob;

int stoi(string s) = #259; /* Part of FTE_QC_INTCONV
    Converts the given string into a true integer. Base 8, 10, or 16 is determined based upon the format of the string. */

string itos(int n) = #260; /* Part of FTE_QC_INTCONV
    Converts the passed true integer into a base10 string. */

int stoh(string s) = #261; /* Part of FTE_QC_INTCONV
    Reads a base-16 string (with or without 0x prefix) as an integer. Bugs out if given a base 8 or base 10 string. :P */

string htos(int n) = #262; /* Part of FTE_QC_INTCONV
    Formats an integer as a base16 string, with leading 0s and no prefix. Always returns 8 characters. */

int ftoi(float f) = #0:ftoi; /* Part of FTE_QC_INTCONV
    Converts the given float into a true integer without depending on extended qcvm instructions. */

float itof(int n) = #0:itof; /* Part of FTE_QC_INTCONV
    Converts the given true integer into a float without depending on extended qcvm instructions. */

float skel_create(float modlindex, optional float useabstransforms) = #263; /* Part of FTE_CSQC_SKELETONOBJECTS
    Allocates a new uninitiaised skeletal object, with enough bone info to animate the given model.
    eg: self.skeletonobject = skel_create(self.modelindex); */


typedef struct
{
	int sourcemodelindex; /*frame data will be imported from this model, bones must be compatible*/
	int reserved;
	int firstbone;
	int lastbone;
	float prescale;	/*0 destroys existing data, 1 retains it*/
	float scale[4];	/*you'll need to do lerpfrac manually*/
	int animation[4];
	float animationtime[4];
	/*halflife models*/
	float subblend[2];
	float controllers[5];
} skelblend_t;
float skel_build(float skel, entity ent, float modelindex, float retainfrac, float firstbone, float lastbone, optional float addfrac) = #264; /* Part of FTE_CSQC_SKELETONOBJECTS
    Animation data (according to the entity's frame info) is pulled from the specified model and blended into the specified skeletal object.
    If retainfrac is set to 0 on the first call and 1 on the others, you can blend multiple animations together according to the addfrac value. The final weight should be 1. Other values will result in scaling and/or other weirdness. You can use firstbone and lastbone to update only part of the skeletal object, to allow legs to animate separately from torso, use 0 for both arguments to specify all, as bones are 1-based. */

float skel_build_ptr(float skel, int numblends, skelblend_t *weights, int structsize) = #0:skel_build_ptr; /*
    Like skel_build, but slightly simpler. */

float skel_get_numbones(float skel) = #265; /* Part of FTE_CSQC_SKELETONOBJECTS
    Retrives the number of bones in the model. The valid range is 1<=bone<=numbones. */

string skel_get_bonename(float skel, float bonenum) = #266; /* Part of FTE_CSQC_SKELETONOBJECTS
    Retrieves the name of the specified bone. Mostly only for debugging. */

float skel_get_boneparent(float skel, float bonenum) = #267; /* Part of FTE_CSQC_SKELETONOBJECTS
    Retrieves which bone this bone's position is relative to. Bone 0 refers to the entity's position rather than an actual bone */

float skel_find_bone(float skel, string tagname) = #268; /* Part of FTE_CSQC_SKELETONOBJECTS
    Finds a bone by its name, from the model that was used to create the skeletal object. */

vector skel_get_bonerel(float skel, float bonenum) = #269; /* Part of FTE_CSQC_SKELETONOBJECTS
    Gets the bone position and orientation relative to the bone's parent. Return value is the offset, and v_forward, v_right, v_up contain the orientation. */

vector skel_get_boneabs(float skel, float bonenum) = #270; /* Part of FTE_CSQC_SKELETONOBJECTS
    Gets the bone position and orientation relative to the entity. Return value is the offset, and v_forward, v_right, v_up contain the orientation.
    Use gettaginfo for world coord+orientation. */

void skel_set_bone(float skel, float bonenum, vector org, optional vector fwd, optional vector right, optional vector up) = #271; /* Part of FTE_CSQC_SKELETONOBJECTS
    Sets a bone position relative to its parent. If the orientation arguments are not specified, v_forward+v_right+v_up are used instead. */

void skel_premul_bone(float skel, float bonenum, vector org, optional vector fwd, optional vector right, optional vector up) = #272; /* Part of FTE_CSQC_SKELETONOBJECTS
    Transforms a single bone by a matrix. You can use makevectors to generate a rotation matrix from an angle. */

void skel_premul_bones(float skel, float startbone, float endbone, vector org, optional vector fwd, optional vector right, optional vector up) = #273; /* Part of FTE_CSQC_SKELETONOBJECTS
    Transforms an entire consecutive range of bones by a matrix. You can use makevectors to generate a rotation matrix from an angle, but you'll probably want to divide the angle by the number of bones. */

void skel_postmul_bone(float skel, float bonenum, vector org, optional vector fwd, optional vector right, optional vector up) = #0:skel_postmul_bone; /*
    Transforms a single bone by a matrix. You can use makevectors to generate a rotation matrix from an angle. */

void skel_copybones(float skeldst, float skelsrc, float startbone, float entbone) = #274; /* Part of FTE_CSQC_SKELETONOBJECTS
    Copy bone data from one skeleton directly into another. */

void skel_delete(float skel) = #275; /* Part of FTE_CSQC_SKELETONOBJECTS
    Deletes a skeletal object. The actual delete is delayed, allowing the skeletal object to be deleted in an entity's predraw function yet still be valid by the time the addentity+renderscene builtins need it. Also uninstanciates any ragdoll currently in effect on the skeletal object. */

float frameforname(float modidx, string framename) = #276; /* Part of FTE_CSQC_SKELETONOBJECTS
    Looks up a framegroup from a model by name, avoiding the need for hardcoding. Returns -1 on error. */

float frameduration(float modidx, float framenum) = #277; /* Part of FTE_CSQC_SKELETONOBJECTS
    Retrieves the duration (in seconds) of the specified framegroup. */

void processmodelevents(float modidx, float framenum, __inout float basetime, float targettime, void(float timestamp, int code, string data) callback) = #0:processmodelevents; /* Part of FTE_GFX_MODELEVENTS
    Calls a callback for each event that has been reached. Basetime is set to targettime. */

float getnextmodelevent(float modidx, float framenum, __inout float basetime, float targettime, __out int code, __out string data) = #0:getnextmodelevent; /*
    Reports the next event within a model's animation. Returns a boolean if an event was found between basetime and targettime. Writes to basetime,code,data arguments (if an event was found, basetime is set to the event's time, otherwise to targettime).
    WARNING: this builtin cannot deal with multiple events with the same timestamp (only the first will be reported). */

float getmodeleventidx(float modidx, float framenum, int eventidx, __out float timestamp, __out int code, __out string data) = #0:getmodeleventidx; /*
    Reports an indexed event within a model's animation. Writes to timestamp,code,data arguments on success. Returns false if the animation/event/model was out of range/invalid. Does not consider looping animations (retry from index 0 if it fails and you know that its a looping animation). This builtin is more annoying to use than getnextmodelevent, but can be made to deal with multiple events with the exact same timestamp. */

#define dotproduct(v1,v2) ((vector)(v1)*(vector)(v2))
vector crossproduct(vector v1, vector v2) = #0:crossproduct; /* Part of FTE_QC_CROSSPRODUCT
    Small helper function to calculate the crossproduct of two vectors. */

float pushmove(entity pusher, vector move, vector amove) = #0:pushmove;

void terrain_edit(float action, optional vector pos, optional float radius, optional float quant, ...) = #278; /* Part of FTE_TERRAIN_MAP
    Realtime terrain editing. Actions are the TEREDIT_ constants. */


typedef struct
{
	string	shadername;
	vector	planenormal;
	float	planedist;
	vector	sdir;
	float	sbias;
	vector	tdir;
	float	tbias;
} brushface_t;
int brush_get(float modelidx, int brushid, brushface_t *out_faces, int maxfaces, int *out_contents) = #0:brush_get; /* Part of FTE_RAW_MAP
    Queries a brush's information. Must pre-allocate face array. Returns number of faces retrieved, 0 on error. */

int brush_create(float modelidx, brushface_t *in_faces, int numfaces, int contents, optional int brushid) = #0:brush_create; /* Part of FTE_RAW_MAP
    Inserts a new brush into the model. Returns the new brush's id. */

void brush_delete(float modelidx, int brushid) = #0:brush_delete; /* Part of FTE_RAW_MAP
    Destroys the specified brush. */

float brush_selected(float modelid, int brushid, int faceid, float selectedstate) = #0:brush_selected; /* Part of FTE_RAW_MAP
    Sets transient visual properties of a brush. Returns old value. selectedstate=-1 changes nothing. */

int brush_getfacepoints(float modelid, int brushid, int faceid, vector *points, int maxpoints) = #0:brush_getfacepoints; /* Part of FTE_RAW_MAP
    Returns vertices of the given face. Face 0 returns center or mins+maxs. */

int brush_calcfacepoints(int faceid, brushface_t *in_faces, int numfaces, vector *points, int maxpoints) = #0:brush_calcfacepoints; /* Part of FTE_RAW_MAP
    Determines points of a face if brush were created. */

int brush_findinvolume(float modelid, vector *planes, float *dists, int numplanes, int *out_brushes, int *out_faces, int maxresults) = #0:brush_findinvolume; /* Part of FTE_RAW_MAP
    Obtains brushes+faces within the bounding region. */

void touchtriggers(optional entity ent, optional vector neworigin) = #279; /* Triggers touch events with SOLID_TRIGGER entities. Optionally updates origin. */

void WriteFloat(float buf, float fl) = #280;

float skel_ragupdate(entity skelent, string dollcmd, float animskel) = #281; /* Updates skeletal object attached to entity. See dollcmd usage comments. */

float* skel_mmap(float skel) = #282; /* Maps bones in VM memory; each bone = 12 floats, four vectors interleaved. */

void skel_set_bone_world(entity ent, float bonenum, vector org, optional vector angorfwd, optional vector right, optional vector up) = #283; /* Sets world position of a bone in entity's skeletal object. */

string frametoname(float modidx, float framenum) = #284;

string skintoname(float modidx, float skin) = #285;

float resourcestatus(float resourcetype, float tryload, string resourcename) = #286; /* Returns RESSTATE_ constants. tryload=1 attempts reload. */

hashtable hash_createtab(float tabsize, optional float defaulttype) = #287; /* Creates a hash table. */

void hash_destroytab(hashtable table) = #288; /* Destroys a hash table. */

void hash_add(hashtable table, string name, __variant value, optional float typeandflags) = #289; /* Adds key/value to table. */

__variant hash_get(hashtable table, string name, optional __variant deflt, optional float requiretype, optional float index) = #290; /* Looks up key in table. */

__variant hash_delete(hashtable table, string name) = #291; /* Removes key from table. Returns value or 0 on error. */

string hash_getkey(hashtable table, float idx) = #292; /* Gets a key name by index. */

float checkcommand(string name) = #294; /* Checks if name is valid command, cvar, or alias. */

string argescape(string s) = #295; /* Marks string for reliable tokenization as single argument. */

void clusterevent(string dest, string from, string cmd, string info) = #0:clusterevent; /* Sends event to cluster server. */

string clustertransfer(entity player, optional string newnode) = #0:clustertransfer; /* Initiates player transfer to a different node. */

float modelframecount(float mdlidx) = #0:modelframecount; /* Retrieves number of frames in model. */

void R_BeginPolygon(string texturename, optional float flags, optional float is2d) = #306; /* Sets shader for following polygons. */

void R_PolygonVertex(vector org, vector texcoords, vector rgb, float alpha) = #307; /* Specifies polygon vertex. */

void R_EndPolygon() = #308; /* Ends current polygon. */

float particleeffectnum(string effectname) = #335; /* Precaches particle effect. */

void trailparticles(float effectnum, entity ent, vector start, vector end) = #336; /* Draws effect between points. */

void pointparticles(float effectnum, vector origin, optional vector dir, optional float count) = #337; /* Spawns particles from effect. */

void print(string s, ...) = #339; /* Prints to local console. */

void runstandardplayerphysics(entity ent) = #347; /* Performs standard player movement prediction. */

float wasfreed(entity ent) = #353; /* Checks if entity is free. */

string serverkey(string key) = #354; /* Look up key in server info string. */

float serverkeyfloat(string key, optional float assumevalue) = #0:serverkeyfloat; /* Version of serverkey returning float. */

__variant* memalloc(int size) = #384; /* Allocates memory block. */

void memfree(__variant *ptr) = #385; /* Frees allocated memory block. */

void memcpy(__variant *dst, __variant *src, int size) = #386; /* Copies memory. */

void memfill8(__variant *dst, int val, int size) = #387; /* Fills memory with value. */

__variant memgetval(__variant *dst, float ofs) = #388; /* Reads 32-bit value at pointer+offset. */

void memsetval(__variant *dst, float ofs, __variant val) = #389; /* Writes 32-bit value at pointer+offset. */

__variant* memptradd(__variant *base, float ofs) = #390; /* Performs pointer math. */

float memstrsize(string s) = #0:memstrsize; /* String length ignoring UTF-8. */

float entityprotection(entity e, float nowreadonly) = #0:entityprotection; /* Changes protection of entity. */

entity copyentity(entity from, optional entity to) = #400; /* Copies all fields from one entity to another. */

void setcolors(entity ent, float colours) = #401; /* Sets player colors. */

entity findchain(.string field, string match, optional .entity chainfield) = #402; 

entity findchainfloat(.float fld, float match, optional .entity chainfield) = #403;

void effect(vector org, string modelname, float startframe, float endframe, float framerate) = #404; /* Spawns self-animating sprite. */


void te_blood(vector org, vector dir, float count) = #405; /* DP_TE_BLOOD */
void te_bloodshower(vector mincorner, vector maxcorner, float explosionspeed, float howmany) = #406; /* _DP_TE_BLOODSHOWER */
void te_explosionrgb(vector org, vector color) = #407; /* DP_TE_EXPLOSIONRGB */
void te_particlecube(vector mincorner, vector maxcorner, vector vel, float howmany, float color, float gravityflag, float randomveljitter) = #408; /* DP_TE_PARTICLECUBE */
void te_particlerain(vector mincorner, vector maxcorner, vector vel, float howmany, float color) = #409; /* DP_TE_PARTICLERAIN */
void te_particlesnow(vector mincorner, vector maxcorner, vector vel, float howmany, float color) = #410; /* DP_TE_PARTICLESNOW */
void te_spark(vector org, vector vel, float howmany) = #411; /* DP_TE_SPARK */
void te_gunshotquad(vector org) = #412; /* _DP_TE_QUADEFFECTS1 */
void te_spikequad(vector org) = #413; /* _DP_TE_QUADEFFECTS1 */
void te_superspikequad(vector org) = #414; /* _DP_TE_QUADEFFECTS1 */
void te_explosionquad(vector org) = #415; /* _DP_TE_QUADEFFECTS1 */
void te_smallflash(vector org) = #416; /* DP_TE_SMALLFLASH */
void te_customflash(vector org, float radius, float lifetime, vector color) = #417; /* DP_TE_CUSTOMFLASH */
void te_gunshot(vector org, optional float count) = #418; /* DP_TE_STANDARDEFFECTBUILTINS */
void te_spike(vector org) = #419; /* DP_TE_STANDARDEFFECTBUILTINS */
void te_superspike(vector org) = #420; /* DP_TE_STANDARDEFFECTBUILTINS */
void te_explosion(vector org) = #421; /* DP_TE_STANDARDEFFECTBUILTINS */
void te_tarexplosion(vector org) = #422; /* DP_TE_STANDARDEFFECTBUILTINS */
void te_wizspike(vector org) = #423; /* DP_TE_STANDARDEFFECTBUILTINS */
void te_knightspike(vector org) = #424; /* DP_TE_STANDARDEFFECTBUILTINS */
void te_lavasplash(vector org) = #425; /* DP_TE_STANDARDEFFECTBUILTINS */
void te_teleport(vector org) = #426; /* DP_TE_STANDARDEFFECTBUILTINS */
void te_explosion2(vector org, float color, float colorlength) = #427; /* DP_TE_STANDARDEFFECTBUILTINS */
void te_lightning1(entity own, vector start, vector end) = #428; /* DP_TE_STANDARDEFFECTBUILTINS */
void te_lightning2(entity own, vector start, vector end) = #429; /* DP_TE_STANDARDEFFECTBUILTINS */
void te_lightning3(entity own, vector start, vector end) = #430; /* DP_TE_STANDARDEFFECTBUILTINS */
void te_beam(entity own, vector start, vector end) = #431; /* DP_TE_STANDARDEFFECTBUILTINS */
void vectorvectors(vector dir) = #432; /* DP_QC_VECTORVECTORS */
void te_plasmaburn(vector org) = #433; /* _DP_TE_PLASMABURN */
float getsurfacenumpoints(entity e, float s) = #434; /* DP_QC_GETSURFACE */
vector getsurfacepoint(entity e, float s, float n) = #435; /* DP_QC_GETSURFACE */
vector getsurfacenormal(entity e, float s) = #436; /* DP_QC_GETSURFACE */
string getsurfacetexture(entity e, float s) = #437; /* DP_QC_GETSURFACE */
float getsurfacenearpoint(entity e, vector p) = #438; /* DP_QC_GETSURFACE */
vector getsurfaceclippedpoint(entity e, float s, vector p) = #439; /* DP_QC_GETSURFACE */
void clientcommand(entity e, string s) = #440; /* KRIMZON_SV_PARSECLIENTCOMMAND */
float tokenize(string s) = #441; /* KRIMZON_SV_PARSECLIENTCOMMAND */
string argv(float n) = #442; /* KRIMZON_SV_PARSECLIENTCOMMAND */
void setattachment(entity e, entity tagentity, string tagname) = #443; /* DP_GFX_QUAKE3MODELTAGS */
searchhandle search_begin(string pattern, float caseinsensitive, float quiet) = #444; /* DP_QC_FS_SEARCH */
void search_end(searchhandle handle) = #445; /* DP_QC_FS_SEARCH */
float search_getsize(searchhandle handle) = #446; /* DP_QC_FS_SEARCH */
string search_getfilename(searchhandle handle, float num) = #447; /* DP_QC_FS_SEARCH */
float search_getfilesize(searchhandle handle, float num) = #0:search_getfilesize; /* FTE_QC_FS_SEARCH_SIZEMTIME */
string search_getfilemtime(searchhandle handle, float num) = #0:search_getfilemtime; /* FTE_QC_FS_SEARCH_SIZEMTIME */
string cvar_string(string cvarname) = #448; /* DP_QC_CVAR_STRING */
entity findflags(entity start, .float fld, float match) = #449; /* DP_QC_FINDFLAGS */
entity findchainflags(.float fld, float match, optional .entity chainfield) = #450; /* DP_QC_FINDCHAINFLAGS */
float gettagindex(entity ent, string tagname) = #451; /* DP_MD3_TAGSINFO */
vector gettaginfo(entity ent, float tagindex) = #452; /* DP_MD3_TAGSINFO */
void dropclient(entity player) = #453; /* DP_SV_DROPCLIENT */
entity spawnclient() = #454; /* DP_SV_BOTCLIENT */
float clienttype(entity client) = #455; /* DP_SV_BOTCLIENT */
void WriteUnterminatedString(float target, string str) = #456; /* DP_SV_WRITEUNTERMINATEDSTRING */
void te_flamejet(vector org, vector vel, float howmany) = #457; /* _DP_TE_FLAMEJET */
entity edict_num(float entnum) = #459; /* DP_QC_EDICT_NUM */
strbuf buf_create() = #460; /* DP_QC_STRINGBUFFERS */
void buf_del(strbuf bufhandle) = #461; /* DP_QC_STRINGBUFFERS */
float buf_getsize(strbuf bufhandle) = #462; /* DP_QC_STRINGBUFFERS */
void buf_copy(strbuf bufhandle_from, strbuf bufhandle_to) = #463; /* DP_QC_STRINGBUFFERS */
void buf_sort(strbuf bufhandle, float sortprefixlen, float backward) = #464; /* DP_QC_STRINGBUFFERS */
string buf_implode(strbuf bufhandle, string glue) = #465; /* DP_QC_STRINGBUFFERS */
string bufstr_get(strbuf bufhandle, float string_index) = #466; /* DP_QC_STRINGBUFFERS */
void bufstr_set(strbuf bufhandle, float string_index, string str) = #467; /* DP_QC_STRINGBUFFERS */
float bufstr_add(strbuf bufhandle, string str, float ordered) = #468; /* DP_QC_STRINGBUFFERS */
void bufstr_free(strbuf bufhandle, float string_index) = #469; /* DP_QC_STRINGBUFFERS */
float asin(float s) = #471; /* DP_QC_ASINACOSATANATAN2TAN */
float acos(float c) = #472; /* DP_QC_ASINACOSATANATAN2TAN */
float atan(float t) = #473; /* DP_QC_ASINACOSATANATAN2TAN */
float atan2(float c, float s) = #474; /* DP_QC_ASINACOSATANATAN2TAN */
float tan(float a) = #475; /* DP_QC_ASINACOSATANATAN2TAN */
float strlennocol(string s) = #476; /* DP_QC_STRINGCOLORFUNCTIONS */
string strdecolorize(string s) = #477; /* DP_QC_STRINGCOLORFUNCTIONS */
string strftime(float uselocaltime, string format, ...) = #478; /* DP_QC_STRFTIME */
float tokenizebyseparator(string s, string separator1, ...) = #479; /* DP_QC_TOKENIZEBYSEPARATOR */
string strtolower(string s) = #480; /* DP_QC_STRING_CASE_FUNCTIONS */
string strtoupper(string s) = #481; /* DP_QC_STRING_CASE_FUNCTIONS */
string cvar_defstring(string s) = #482; /* DP_QC_CVAR_DEFSTRING */
void pointsound(vector origin, string sample, float volume, float attenuation) = #483; /* DP_SV_POINTSOUND */
string strreplace(string search, string replace, string subject) = #484; /* DP_QC_STRREPLACE */
string strireplace(string search, string replace, string subject) = #485; /* DP_QC_STRREPLACE */
vector getsurfacepointattribute(entity e, float s, float n, float a) = #486; /* DP_QC_GETSURFACEPOINTATTRIBUTE */
float crc16(float caseinsensitive, string s, ...) = #494; /* DP_QC_CRC16 */
float cvar_type(string name) = #495; /* DP_QC_CVAR_TYPE */
float numentityfields() = #496; /* DP_QC_ENTITYDATA */
float findentityfield(string fieldname) = #0:findentityfield; 
typedef .__variant field_t;
field_t entityfieldref(float fieldnum) = #0:entityfieldref;
string entityfieldname(float fieldnum) = #497; /* DP_QC_ENTITYDATA */
float entityfieldtype(float fieldnum) = #498; /* DP_QC_ENTITYDATA */
string getentityfieldstring(float fieldnum, entity ent) = #499; /* DP_QC_ENTITYDATA */
float putentityfieldstring(float fieldnum, entity ent, string s) = #500; /* DP_QC_ENTITYDATA */
void WritePicture(float to, string s, float sz) = #501; /* DP_SV_WRITEPICTURE */
string whichpack(string filename, optional float makereferenced) = #503; /* DP_QC_WHICHPACK */
string uri_escape(string in) = #510; /* DP_QC_URI_ESCAPE */
string uri_unescape(string in) = #511; /* DP_QC_URI_ESCAPE */
float num_for_edict(entity ent) = #512;
#define uri_post uri_get
float uri_get(string uril, float id, optional string postmimetype, optional string postdata) = #513; /* DP_QC_URI_GET/POST */
float tokenize_console(string str) = #514; 
float argv_start_index(float idx) = #515;
float argv_end_index(float idx) = #516;
void buf_cvarlist(strbuf strbuf, string pattern, string antipattern) = #517;
string cvar_description(string cvarname) = #518;
float gettime(optional float timetype) = #519;
void loadfromdata(string s) = #529;
void loadfromfile(string s) = #530;
void setpause(float pause) = #531;
float precache_vwep_model(string mname) = #532;
float log(float v, optional float base) = #532;
float buf_loadfile(string filename, strbuf bufhandle) = #535;
float buf_writefile(filestream filehandle, strbuf bufhandle, optional float startpos, optional float numstrings) = #536;
float physics_supported(optional float force) = #0:physics_supported;
void physics_enable(entity e, float physics_enabled) = #540;
void physics_addforce(entity e, vector force, vector relative_ofs) = #541;
void physics_addtorque(entity e, vector torque) = #542;
void callfunction(.../*, string funcname*/) = #605;
void writetofile(filestream fh, entity e) = #606;
float isfunction(string s) = #607;
float parseentitydata(entity e, string s, optional float offset) = #613;
string generateentitydata(entity e) = #0:generateentitydata;
string netaddress_resolve(string dnsname, optional float defport) = #625;
string sprintf(string fmt, ...) = #627;
float getsurfacenumtriangles(entity e, float s) = #628;
vector getsurfacetriangle(entity e, float s, float n) = #629;
string digest_hex(string digest, string data, ...) = #639;

#ifdef _ACCESSORS
accessor strbuf : float
{
	inline get float asfloat[float idx] = {return stof(bufstr_get(this, idx));};
	inline set float asfloat[float idx] = {bufstr_set(this, idx, ftos(value));};
	get string[float] = bufstr_get;
	set string[float] = bufstr_set;
	get float length = buf_getsize;
};
accessor searchhandle : float
{
	get string[float] = search_getfilename;
	get float length = search_getsize;
};
accessor hashtable : float
{
	inline get vector v[string key] = {return hash_get(this, key, '0 0 0', EV_VECTOR);};
	inline set vector v[string key] = {hash_add(this, key, value, HASH_REPLACE|EV_VECTOR);};
	inline get string s[string key] = {return hash_get(this, key, "", EV_STRING);};
	inline set string s[string key] = {hash_add(this, key, value, HASH_REPLACE|EV_STRING);};
	inline get float f[string key] = {return hash_get(this, key, 0.0, EV_FLOAT);};
	inline set float f[string key] = {hash_add(this, key, value, HASH_REPLACE|EV_FLOAT);};
	inline get __variant[string key] = {return hash_get(this, key, __NULL__);};
	inline set __variant[string key] = {hash_add(this, key, value, HASH_REPLACE);};
};
accessor infostring : string
{
	get string[string] = infoget;
	inline seti& string[string fld] = {this = infoadd(this, fld, value);};
};
accessor filestream : float
{
	get string = fgets;
	inline set string = {fputs(this,value);};
};
#endif
#pragma noref 0
